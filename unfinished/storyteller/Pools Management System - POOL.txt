@@ DEPENDENCIES - CORE

th u(newcobj,STORYTELLER: Pools Management System <POOL>,pool,,,,WIZARD SAFE !NO_COMMAND,INHERIT SIDEFX SAFE)
th u(newconf,CONFIG,STORYTELLER,POOLS,PLAYER_GAIN,1,Players can refill pools?,BOOL)

&CMD`+POOL [u(cobj,pool)]=$^\+(spend|gain|refresh|commit|uncommit|pools|fill|drain)(?\: +(.+?))?(?\:=(.*))?$:@attach %!/INC`%1=%2,%3
@set [u(cobj,pool)]/CMD`+POOL=regexp

&SYSTEM`NAME [u(cobj,pool)]=POOLS
&SWITCHES`PLAYER [u(cobj,pool)]=
&SWITCHES`ADMIN [u(cobj,pool)]=

&INC`FINDPOOL [u(cobj,pool)]=@check strlen(%0)=@attach %!/INC`MSG=ERROR: What resource? Your choices are: [u(itemize,u(FUN`LISTPOOLS,%1),|,and,\,)];@attach %!/INC`PARTIAL=%0,u(filter,OPTIONS,u(FUN`LISTPOOLS,%1),|,|,%2),|,POOLS,choice,pool

&FUN`POOLDETAIL [u(cobj,pool)]=v(POOL`%0`UNITNAME) of [u(capnames,v(POOL`%0`UNITTYPE))]

&FUN`LISTPOOLS [u(cobj,pool)]=localize(u(sortpools,u(filter,HASPOOL,u(FUN`ALLPOOLS),|,|,%0,u(setr,class,getclass(%0)),if(strlen(%1),%1,*),v(CLASS`%q<class>)),|,|))

&FUN`ALLPOOLS [u(cobj,pool)]=edit(u(lattr,%!/POOL`*,|),POOL`,)

&FIL`HASPOOL [u(cobj,pool)]=cand(strmatch(v(POOL`%0),%3),cor(match(%4,%0),u(POOL`%0`HAVE,%1),u(getstat,%0,D`HASPOOL,%0)))

&SORTPOOLS [u(cobj,pool)]=u(SORTPOOLS`[v(game)],%0,if(strlen(%1),%1,%B),if(strlen(%2),%2,%B))
&SORTPOOLS`PENNMUSH [u(cobj,pool)]=sortkey(#lambda/default(%!/POOL`\%0`ORDER,99),%0,n,%1,%2)
&SORTPOOLS`RHOSTMUSH [u(cobj,pool)]=sortby(#lambda/[lit([ncomp(default(%!/POOL`%0`ORDER,99),default(%!/POOL`%1`ORDER,99))])],%0,%1,%2)

&INC`ADMIN [u(cobj,pool)]=@check u(isadmin,%#)=@attach %!/INC`MSG=ERROR: Permission denied.;@attach %!/INC`CHECKPC=before(%0,/),1;@attach %!/INC`FINDPOOL=after(%0,/),%q<t1>,switch(%2,FILL,GAIN,DRAIN,SPEND);@attach %!/INC`VALID`POSINT=before(%1,/),switch(%2,FILL,Gain,DRAIN,Spend);th u(setq,reason,after(%1,/))

&INC`DRAIN [u(cobj,pool)]=@attach %!/INC`ADMIN=%0,%1,DRAIN;@stop lt(u(FUN`CUR,%q<t1>,%q<choice>),%q<value>)=@attach %!/INC`MSG=There aren't enough [u(FUN`POOLDETAIl,%q<choice>)] in %q<t1name>'s [v(POOL`%q<choice>)]!;@attach %!/INC`MSG`ROOM=u(setr,msg,Drained %q<value> [u(FUN`POOLDETAIL,%q<choice>)] from %q<t1name> for: [u(strfirstof,%q<reason>,No reason given!)]),lcon(loc(%q<t1>));@attach %!/INC`MSG`CHAN=%q<msg>;&D`POOLS`%q<choice>`CUR %q<t1>=sub(get(%q<t1>/D`POOLS`%q<choice>`CUR),%q<value>)

&INC`SPEND [u(cobj,pool)]=@attach %!/INC`FINDPOOL=%0,%#;@check strlen(%1)=@attach %!/INC`MSG=ERROR: Burn Value empty.;@attach %!/INC`VALID`POSINT=before(%1,/),Spend;@stop lt(u(FUN`CUR,%#,%q<choice>),%1)=@attach %!/INC`MSG=There aren't enough [u(FUN`POOLDETAIL,%q<choice>)] in that [v(POOL`%q<choice>)]!;@attach %!/INC`MSG`ROOM=spent %q<value> [u(FUN`POOLDETAIL,%q<choice>)][if(strlen(after(%1,/)),%bfor%b[after(%1,/)])]!;@attach %!/INC`MSG`CHAN=Spent %q<value> [u(FUN`POOLDETAIL,%q<choice>)] on: [u(strfirstof,after(%1,/),NO REASON GIVEN!)];&D`POOLS`%q<choice>`CUR %#=sub(get(%#/D`POOLS`%q<choice>`CUR),%q<value>)

&INC`FILL [u(cobj,pool)]=@attach %!/INC`ADMIN=%0,%1,FILL;@attach %!/INC`MSG`ROOM=u(setr,msg,Gave %q<t1name> %q<value> [u(FUN`POOLDETAIL,%q<choice>)] for: [u(strfirstof,%q<reason>,No reason given!)]),lcon(loc(%q<t1>));@attach %!/INC`MSG`CHAN=%q<msg>;&D`POOLS`%q<choice>`CUR %q<t1>=bound(add(get(%q<t1>/D`POOLS`%q<choice>`CUR),%q<value>),0,min(u(FUN`TOTALCOMMIT,%q<t1>,%1),u(FUN`MAX,%q<t1>,%1)))

&INC`GAIN [u(cobj,pool)]=@check cor(u(isadmin,%#),u(game_config,STORYTELLER,POOLS,PLAYER_GAIN))=@attach %!/INC`MSG=ERROR: Permission denied. Players must rely on Storytellers or 'hunts' to re-fill their resources.;@attach %!/INC`FINDPOOL=%0,%#,GAIN;@check strlen(%1)=@attach %!/INC`MSG=ERROR: Regain Value empty.;@attach %!/INC`VALID`POSINT=before(%1,/),Gain;@attach %!/INC`MSG`ROOM=Gained %q<value> [u(FUN`POOLDETAIL,%q<choice>)][if(strlen(after(%1,/)),%bfor%b[after(%1,/)])]!;@attach %!/INC`MSG`CHAN=Gained %q<value> [u(FUN`POOLDETAIL,%q<choice>)] for: [u(strfirstof,after(%1,/),NO REASON GIVEN!)];&D`POOLS`%q<choice>`CUR %#=bound(add(get(%#/D`POOLS`%q<choice>`CUR),%q<value>),0,min(u(FUN`TOTALCOMMIT,%#,%1),u(FUN`MAX,%#,%1)))

&FUN`TOTALCOMMIT [u(cobj,pool)]=lmath(add,iter(u(lattr,%0/D`POOLS`%1`COMMIT`*),get(%0/%i0)))

&FUN`CUR [u(cobj,pool)]=bound(sub(u(FUN`MAX,%0,%1),get(%0/D`POOLS`%1`CUR)),0,min(u(FUN`TOTALCOMMIT,%0,%1),u(FUN`MAX,%0,%1)))

&FUN`MAX [u(cobj,pool)]=add(u(POOL`%1`MAX,%0),u(getstat,%0,D`POOLBONUS,%1))

&INC`REFRESH [u(cobj,pool)]=@check cor(u(isadmin,%#),u(game_config,STORYTELLER,POOLS,PLAYER_GAIN))=@attach %!/INC`MSG=ERROR: Permission denied. Players must rely on Storytellers or 'hunts' to re-fill their resources.;@dolist/inline/delimit | [u(filter,OPTIONS,u(FUN`LISTPOOLS,%#),|,|,REFRESH)]=&D`POOLS`##`CUR %#=bound(u(strfirstof,u(POOL`%0`INIT,%#),0),0,u(FUN`TOTALCOMMIT,%#,##));@attach %!/INC`MSG`ROOM=Refreshed %p resources!;@attach %!/INC`MSG`CHAN=Refresh %p resources!

&FIL`OPTIONS [u(cobj,pool)]=t(match(v(POOL`%0`OPTIONS),%1))

&INC`COMMIT [u(cobj,pool)]=@attach %!/INC`FINDPOOL=before(%0,/),%#,COMMIT;@check strlen(after(%0,/))=@attach %!/INC`MSG=ERROR: Commit Value empty.;@attach %!/INC`VALID`POSINT=after(%0,/),Commit Values;@stop lt(u(FUN`CUR,%#,%q<choice>),after(%0,/))=@attach %!/INC`MSG=There aren't enough [u(FUN`POOLDETAIL,%q<choice>)] in that [v(VAR`POOL`%q<choice>`TYPE)]!;@check strlen(%1)=@attach %!/INC`MSG=ERROR: No reason entered for this Commitment!;&[u(setr,attr,D`POOLS`%q<choice>`COMMIT`[nextslot(%#,D`POOLS`%q<choice>`COMMIT)])] %#=after(%0,/);&D`POOLS`%q<choice>`CUR %#=bound(sub(get(%#/D`POOLS`%q<choice>`CUR),after(%0,/)),0,u(FUN`MAX,%#,%q<choice>));&%q<attr>`REASON %#=%1;@nsremit %l=msghead(POOLS) [ansi(h,%n)] just Committed [after(%0,/)] [u(FUN`POOLDETAIL,%q<choice>)] to: %1

&INC`UNCOMMIT [u(cobj,pool)]=@attach u(ex-pso)/INC`FINDPOOL=%0,%#;@check valnum(%1)=@attach %!/INC`MSG=ERROR: Uncommit target empty.;@check hasattr(%#/D`POOLS`%q<choice>`COMMIT`%1)=@attach %!/INC`MSG=ERROR: No Commitment matches that slot.;@nsremit %l=msghead(POOLS) [ansi(h,%n)] just released [get(%#/D`POOLS`%q<choice>`COMMIT`%1)] [u(FUN`POOLDETAIL,%q<choice>)] from: [get(%#/D`POOLS`%q<choice>`COMMIT`%1`REASON)];@wipe %#/D`POOLS`%q<choice>`COMMIT`%1

&INC`POOLS [u(cobj,pool)]=@select/inline and(isadmin(%#),strlen(%0))=1,{@attach u(ccs)/INC`CHECKPC=%0,1,POOLS},0,{th u(setq,t1,%#)};@pemit %#=header(name(%q<t1>)'s Pools);@dolist/inline u(FUN`LISTPOOLS,%q<t1>)={@pemit %#=rjust(capnames(%i0),10): [rjust(u(FUN`CUR,%q<t1>,%i0),3,0)]/[rjust(u(FUN`MAX,%q<t1>,%i0),3,0)][if(nattr(%q<t1>/D`POOLS`%i0`COMMIT`*),%R[iter(u(lattr,%q<t1>/D`POOLS`%i0`COMMIT`*),%T[last(%i0,`)]: [rjust(get(%q<t1>/%i0),3)] for [get(%q<t1>/%i0`REASON)],%B,%R)])]};@pemit %#=header()

&POOL [u(cobj,pool)]=@@ Empty attrib for Rhost.


+help/addmain Roleplaying/+pools=[u(ex-pso)]/HLP`+POOLS
&HLP`+POOLS [u(cobj,pool)]=[ansi(h,+pools)]%RDisplays your current Pool information, including Commitments.%R%R[ansi(h,+burn <poolname>=<#>)]%RUses up some of a pool, aka subtracts from it. Used for spending Essence, clearing up Limit, etc.%R%R[ansi(h,+gain <poolname>=<#>)]%RRestores a Pool, aka adds to it. Used for refilling Essence, gaining Limit, etc.%R%R[ansi(h,+refresh)]%RRestores all Pools and Channels (willpower, virtues, etc) but leaves Tracks such as Limit alone.%R%R[ansi(h,+commit <poolname>/<#>=<reason>)]%RCommits a number of points for a given reason. Example: +commit Peripheral/5=Daiklave%RIf used on Tracks like Limit, Commits raise the minimum instead of lowering maximum- 2 points of Committed Limit mean you're always at least at 2/10, for instance.%R%R[ansi(h,+uncommit <pool>=<commit ID>)]%RRemoves a commitment. Use +pools to see which commitment slot to free up.%R%RNote: Pool names take partial matches!