@@ Scene System - All credits to Mercutio! Version: 73

@switch/inline isdbref(u(scenesys))=0,{@tel create(Scene System)=config(master_room)}
&scenesys u(coi)=locate(config(master_room),Scene System,TXxi)
@parent u(scenesys)=u(coi)
@set u(scenesys)=WIZARD !NO_COMMAND VISUAL ORPHAN

&CMD`SCENE u(scenesys)=$(?s)^\+(scene|scenes|schedule|tp|tps)(?\:/(\S+))?(?\: +(.+?))?(?\:=(.*))?$:@include u(scenesys)/INC`INIT`%1;@include u(scenesys)/INC`PARTIAL=%2,setunion(get(u(scenesys)/VAR`%1`PLAYFLAGS),if(isadmin(%#),get(u(scenesys)/VAR`%1`ADMINFLAGS)),|,|),|,SCENE,switch,switch;@include u(scenesys)/INC`%1`[strfirstof(%q<switch>,MAIN)]=
@set u(scenesys)/CMD`SCENE=regexp

&VAR`SCENE`PLAYFLAGS u(scenesys)=RECALL|JOIN

&ACONNECT u(scenesys)=@dolist lattr(me/TRG`ACONNECT`)=@include me/%i0=%:
&TRG`ACONNECT`MISSED_POSE u(scenesys)=@assert setr(PoseIDs,u(w`query,get`pose`from_till_now,u(FUN`sql`timeformat,convtime(get(%0/lastlogout))), setr(SceneID,u(FUN`get`activescene,u(FUN`get`playerid,%0)))));@wait 3=@nspemit %0={Our records indicate you missed some poses. Use +scene/recall [words(%q<PoseIDs>)]=%q<SceneID>}

&CMDALIAS u(scenesys)=Using the power of @include to show how easy it is to make a command alias.
&CMDALIAS`SCHEDULE u(scenesys)=$^[@+-=!.~]?(?\:scenes|schedule|tp|tps)(?\:\s(.+))?$:@assert strlen(%1)=@include me/cmds`schedule ; @include me/cmds`schedule`view=,%1
@set u(scenesys)/CMDALIAS`SCHEDULE=regexp
&CMDS u(scenesys)=Contains the commands. This system is REGEXP rich - which means that, if you are intent on changing these, you had better know what you are doing.
&CMDS`ACTIVATE u(scenesys)=$^[@+-=!.~]?scene(?\:/|\s+#)activate(?\:\s+(.+))?$:                                                                                   @@ Activates scene ## assuming that you are /in/ that scene, as dictated by the POSER table. If no scene is given, it will assume you are trying to activate the one you were in most recently.                                                                                                              Arguments= %1: Scene ID                                                                                                                                   ; th setq(SceneID,firstof( %1 , u(FUN`get`scene`lastvalidactive, u(FUN`get`playerid,%:) ) ))[@@(Puts the true scene into %q<SceneID>)]                                                                                     ; @assert u(FUN`is`scene`id,%q<SceneID>)=                                       @pemit %#=u(FUN`msg,nosuchscene,%q<SceneID>)                               ; @include me/include`activate=%q<SceneID>,%:,u(FUN`get`playerid,%:),%:
@set u(scenesys)/CMDS`ACTIVATE=regexp
&CMDS`ADDPLAYER u(scenesys)=$^[@+-=!.~]?scene(?\:/|\s+#)addplayer(?\:\s+(.+?)(?\:=(.+))?)$:                                                                                          @@ This system adds a player to a scene, without checking for the locks.     Only available to staff and scene-owners.                                                                                                                 Arguments = %1: Player Ref, %2: Scene ID                                                                                                                  ; @assert setr(PlayerRef,objid(u(FUN`locate,%1)))=                              @pemit %#=u(FUN`msg,nosuchplayer,%q<PlayerRef>)                             ; @assert setr(PlayerID,u(FUN`get`playerid,%q<PlayerRef>))=                     @pemit %#=u(FUN`msg,nosuchplayerid,%q<PlayerID>)                                                                                                        ; th setq(SceneID,firstof(%2,u(FUN`get`scene`recentatloc,objid(%l))))                                                                                      ; @assert or(u(FUN`is`sceneowner,%q<SceneID>,%:),u(FUN`is`staff,%:))=            @pemit %#=u(FUN`msg,cannotaddtoscene,%q<SceneID>,%q<PlayerID>)             ; @include me/include`scene`addplayer=%q<SceneID>,%q<PlayerRef>,1,%:
@set u(scenesys)/CMDS`ADDPLAYER=regexp
&CMDS`CONFIG u(scenesys)=$^[@+-=!.~]?scene(?\:/|\s+#)config(?\:/view)?(?\:\s+([^=]+))?$:                                                                                          @@ This is the configuration system. It allows for different levels of access and displays configuration for the admin. Setting gets done in another system.                                                                                                                                           Arguments = %1: text                                                                                                                                     ; @assert %1=                                                                  @pemit %#=u(FUN`display`config)[@@(No arguments? Simple table!)];                                                                                        ; @break u(FUN`is`table,v(data`sql`table`config),%1)=                           @pemit %#=u(FUN`display`config,%1)[@@(We have a table!)]                                                                                                 ; @break not(and(u(FUN`is`scene`id,first(%1,/)),eq(words(%1),1)))=              @pemit %#=u(FUN`msg,That wasn't a scene id nor a configuration setting.)                                                                                 ; @assert or(u(FUN`is`table,v(data`sql`table`config),rest(%1,/)) ,                eq(strlen(rest(%1,/)),0)) =                                                @pemit %#=u(FUN`msg,That is not a valid setting to display.)                                                                                             ; @pemit %#=u(FUN`display`config,rest(%1,/),first(%1,/))[@@(We have a scene id!)]
@set u(scenesys)/CMDS`CONFIG=regexp
&CMDS`CONFIG`SET u(scenesys)=$^[@+-=!.~]?scene(?\:/|\s+#)(?\:config[/ ]?(?\:set)?|(?\:set)?[/ ]?config)\s+(?\:(.+?)/)?(.+?)=(.+)$:                                                                                              @@ This is the configuration setting system. Some funky stuff here. Let's see what asumptions we make, okay? %1 is always a scene. %2 is always the 'setting'. What it applies to when %1 is omitted: For admin, it means it is global. For sceneowner, it means 'activescene'. %3 is always 'what we set it to'. But we'll let include`config`set figure that out for us.                                                                                             ; @assert switch(strlen(%1),0,1,u(FUN`is`scene`id,%1))=                         @pemit %#=u(FUN`msg,Invalid Scene ID!)                                      ; @include me/include`configset=%1,%:,%2,%3
@set u(scenesys)/CMDS`CONFIG`SET=regexp
&CMDS`CREATE u(scenesys)=$(?s)^[@+-=!.~]?scene(?\:/|\s+#)(?\:create|start)(?\:\s+(.+))?$:                                                                                          @@ This is the command that gets run to create a scene. It will use a simple regexp to generate scene information, allowing the command-syntax to be user-friendly.                                                                                                                                            Arguments: %1 Creation Line                                                                                                                               ; @include me/include`create=firstof(%1,announce=no),%:
@set u(scenesys)/CMDS`CREATE=regexp
&CMDS`DEACTIVATE u(scenesys)=$^[@+-=!.~]?scene(?\:/|\s+#)deactivate(?\:\s+(.+))?$:                                                                              @@ De-activates the scene you are currently in. A staffer can force this on a player. Does not leave a scene!                                                                                                                         Arguments= %1: Player                                                                                                                                     ; @assert strlen(%1)=                                                          @include me/include`deactivate=u(FUN`get`playerid,%:),%:,%:                                                                                              ; @assert u(FUN`is`staff,%#)=                                                   @pemit %#=u(FUN`msg,notstaff)                                                                                                                            ; @assert setr(PlayerID,u(FUN`get`playerid,setr(PlayerDB,u(FUN`locate,%1)))) =   @pemit %#=u(FUN`msg,nosuchplayerid)                                                                                                                      ; @include me/include`deactivate=%q<PlayerID>,objid(%q<PlayerDB>),%:
@set u(scenesys)/CMDS`DEACTIVATE=regexp
&CMDS`DESETUP u(scenesys)=$^[@+-=!.~]?scene(?\:/|\s+#)desetup(?\:\s+(.+))$:                                                                                      @@ This is ran by an admin to remove a playerid, and thus making it so that any player that might have listened to that playerid, is no longer set up for SceneSys. It'll check if the playerid exists.                                                                                                         Arguments= %1: dbref/objid/name                                                                                                                           ; @assert u(FUN`is`playerid,                                                            setr(PlayerID,firstof(u(FUN`get`playerid,objid(pmatch(%1))),%1))) =   @pemit %#=u(FUN`msg,playerid`not,%q<PlayerID>)                              ; @include me/include`player`desetup=%:,%q<PlayerID>
@set u(scenesys)/CMDS`DESETUP=regexp
&CMDS`FINISH u(scenesys)=$^[@+-=!.~]?scene(?\:/|\s+#)finish$:                                                                                       @@ This is ran by a player to set a scene they are currently in, as finished. They need to be the owner, or staff of course. It will then deactivate the scene for all players in it. ;                      @assert setr(SceneID,u(FUN`get`activescene,u(FUN`get`playerid,%:)))= @pemit %#=You are not in a scene. ;  @assert or(u(FUN`is`sceneowner,%q<SceneID>,%:),u(FUN`is`staff,%:))=@pemit %#=You don't own this scene. ; @inc me/include`configset=%q<SceneID>,%#,scene_state,3 ; @inc me/include`configset=%q<SceneID>,%#,scene_etime,u(FUN`sql`timeformat) ; @pemit %#=Finished!
@set u(scenesys)/CMDS`FINISH=regexp
&CMDS`FINISH_ALT u(scenesys)=$^[@+-=!.~]?scene(?\:/|\s+#)finish(?\:\s+(\d+))$:                                                                                       @@ This is ran by a player to set a scene they indicate, as finished. They need to be the owner, or staff of course. It will then deactivate the scene for all players in it. ;                      @assert setr(SceneID,u(FUN`is`scene`id,%1))= @pemit %#=We can't find that scene. ;  @assert or(u(FUN`is`sceneowner,%q<SceneID>,%:),u(FUN`is`staff,%:))=@pemit %#=You don't own that scene. ; @inc me/include`configset=%q<SceneID>,%#,scene_state,3 ; @inc me/include`configset=%q<SceneID>,%#,scene_etime,u(FUN`sql`timeformat) ; @pemit %#=Finished!
@set u(scenesys)/CMDS`FINISH_ALT=regexp
&CMDS`HELP u(scenesys)=$^[@+-=!.~]?scene(?\:/|\s+#)h(?\:e(?\:lp?)?)?(?\:\s+(.+))?$:                                                                              @@ Built In Help System - for ease of use.                                   Arguments = %1: helpfile                                                                                                                                 ; @pemit %#=u(FUN`display`help,firstof(%1,index))
@set u(scenesys)/CMDS`HELP=regexp
&CMDS`INFO u(scenesys)=$^[@+-=!.~]?scene(?\:(?\:(?\:/|\s+#)info)(?\:\s+([^#]+))?|(?\:\s+([^#]+)))$:                                                                                 @@ This is the scene-info command. It shows basic info, similar to the +scene/config/view command, but also shows important information.                                                                                            Arguments = %1: text                                                                                                                                          ; @assert setr(SceneID,u(FUN`is`scene`id,                                                 firstof(%1,rest(%0),u(FUN`get`activescene,u(FUN`get`playerid,%:))))) =               @pemit %#=u(FUN`msg,nosuchscene,%1)                                                                                                                           ; @pemit %#=u(FUN`display`sceneinfo,%q<SceneID>)
@set u(scenesys)/CMDS`INFO=regexp
&CMDS`INSTALL u(scenesys)=$^[@+-=!.~]?scene(?\:(?\:/|\s+#)install)$:  @@ Simply sets the listen information on the object indicated. ; @nspemit %#=Installing (install script to be rewritten)
@set u(scenesys)/CMDS`INSTALL=regexp
&CMDS`INSTALL`LISTEN u(scenesys)=^*:@@ This listen throws whatever it hears at the SceneSys object.                                                                                                                                                  ; @trig v(scene`object)/include`pose=[u(v(scene`object)/fn`get`name,%#)] , %: , %0 , [u(v(scene`object)/fn`sql`timeformat)]
@set u(scenesys)/CMDS`INSTALL`LISTEN=regexp
&CMDS`INSTALL`TRUNK u(scenesys)=Contains the SceneSys listen. Remember to set your rooms LISTEN_PARENT!
@set u(scenesys)/CMDS`INSTALL`TRUNK=regexp
&CMDS`JOIN u(scenesys)=$^[@+-=!.~]?scene(?\:/|\s+#)join(?\:\s+(\d+))?$:                                                                                          @@ We will use a smart system to check if there was any recent activity in this room. If so, assume that is the scene to add them to. If an argument is given, add them to the given ScenID instead. You cannot join a FINISHED or UNFINISHED scene. Only 'paused' and 'activated' ones.                                                                                            Arguments = %1: Scene ID                                                                                                                                  ; th setq(SceneID,firstof(%1,u(FUN`get`scene`recentatloc,objid(%l))))                                                                                     ; @assert u(FUN`is`scene`id,%q<SCeneID>) =               @pemit %#=u(FUN`msg,nosuchscene,%q<SceneId>) ; @assert u(FUN`is`abletojoin,%q<SceneID>,%:)=                                  @pemit %#=u(FUN`msg,cannotjoinscene,%q<SceneID>,%1)                         ; @include me/include`scene`addplayer=%q<SceneID>,%:,1,%:
@set u(scenesys)/CMDS`JOIN=regexp
&CMDS`KICK u(scenesys)=$^[@+-=!.~]?scene(?\:/|\s+#)kick(?\:\s+(.+?)(?\:=(.+))?)$:                                                                                @@ This system removes a player from a scene, without checking for the locks, and locks it against them. Only available to staff and scene-owners.                                                                               Arguments = %1: Player Ref, %2: Scene ID                                                                                                                  ; @assert setr(PlayerRef,objid(u(FUN`locate,%1)))=                              @pemit %#=u(FUN`msg,nosuchplayer,%q<PlayerRef>)                             ; @assert setr(PlayerID,u(FUN`get`playerid,%q<PlayerRef>))=                     @pemit %#=u(FUN`msg,nosuchplayerid,%q<PlayerID>)                                                                                                         ; th setq(SceneID,firstof(%2,u(FUN`get`scene`recentatloc,objid(%l))))                                                                                      ; @assert or(u(FUN`is`sceneowner,%q<SceneID>,%:),u(FUN`is`staff,%:))=            @pemit %#=u(FUN`msg,cannotremfromscene,%q<SceneID>,%q<PlayerRef>)           ; @include me/include`scene`remplayer=%q<SceneID>,%q<PlayerRef>,%:           ; @include me/include`lock`kickplayer=%q<SceneID>,%q<PlayerRef>,%:           ; @trig me/include`kick=%q<PlayerRef>,%q<SceneID>,%:
@set u(scenesys)/CMDS`KICK=regexp
&CMDS`LEAVE u(scenesys)=$^[@+-=!.~]?scene(?\:/|\s+#)leave(?\:\s+(.+))?$:                                                                                         @@ This will assume that when there is no argument, it is the 'active scene'. This command itself does no checking other than that.                                                                                          Arguments = %1: Scene ID                                                                                                                                  ; th setq(SceneID,firstof(%1,u(FUN`get`activescene,u(FUN`get`playerid,%:))))                                                                                ; @include me/include`leave=%q<SceneID>,%:,%:
@set u(scenesys)/CMDS`LEAVE=regexp
&CMDS`LIST u(scenesys)=$^[@+-=!.~]?scene(?\:/|\s+#)list(?\:\s(.+))?$:               @@ This command will somehow show a 'list' of scenes.                                                                                                     Arguments= %1: status                                                                                                                                     ; th setr(SceneState,firstof(edit(%1,*,all,?,all),v(data`defaultlist)))              [@@('active' as default)]                                              ; @assert lmatch(active unfinished paused finished all,%q<SceneState>)=            @pemit %#=u(FUN`msg,invalidstatus,%1)                                                                                                                    ; @dol header [u(FUN`get`list,u(FUN`get`state`tonum,%q<SceneState>))] footer=       @pemit %#=u(FUN`display`listitem,%il,%q<SceneState>)
@set u(scenesys)/CMDS`LIST=regexp
&CMDS`MINE u(scenesys)=$^[@+-=!.~]?scene(?\:(?\:/|\s+#)(?\:mine|my)?)?(?\:(?<=mine|my)\s+(.+))?$:                                                                     @@ This is the MyScene command. It shows pose-order, current unfinished scenes, most recent pose, what scene is active....                                                                                                     Arguments = %1: player (for staff only)                                                                                                                   ; @break and(strlen(%1),not(u(FUN`is`staff,%#))) =                              @pemit %#=u(FUN`msg,notstaff)                                                                                                                            ; @break and( strlen(%1) , not(u(FUN`is`playerid,                                      setr(PlayerID,u(FUN`get`playerid,objid(pmatch(%1))))))) =              @pemit %#=u(FUN`msg,nosuchplayer,%q<PlayerID>)                                                                                                           ; @pemit %#=u(FUN`display`myscene,firstof(%q<PlayerID>,                                   u(FUN`get`playerid,%:)),firstof(objid(pmatch(%1)),%:))
@set u(scenesys)/CMDS`MINE=regexp
&CMDS`MINE`FINISHED u(scenesys)=$^[@+-=!.~]?scene(?\:(?\:/|\s+#)mine|my)(?\:(?\:/|\s+#)(?\:finish|finished)(?\:\s+(.+))?)$:                                                                     @@ This is the MyScene command. It shows pose-order, current finished scenes, most recent pose, what scene is active....                                                                                                     Arguments = %1: player (for staff only)                                                                                                                   ; @break and(strlen(%1),not(u(FUN`is`staff,%#))) =                              @pemit %#=u(FUN`msg,notstaff)                                                                                                                            ; @break and( strlen(%1) , not(u(FUN`is`playerid,                                      setr(PlayerID,u(FUN`get`playerid,objid(pmatch(%1))))))) =              @pemit %#=u(FUN`msg,nosuchplayer,%q<PlayerID>)                                                                                                           ; @pemit %#=u(FUN`display`myscene`top,setr(PlayerID,firstof(%q<PlayerID>,                                   u(FUN`get`playerid,%:))),firstof(objid(pmatch(%1)),%:),finished); @dol/notify [u(FUN`get`scene`playerparticipated,%q<PlayerID>,3)]=@pemit %#=u(FUN`display`myscene`list,##,%q<PlayerID>) ; @wait me=@pemit %#=[u(FUN`display`midline)]
@set u(scenesys)/CMDS`MINE`FINISHED=regexp
&CMDS`MINE`UNFINISHED u(scenesys)=$^[@+-=!.~]?scene(?\:(?\:/|\s+#)mine|my)(?\:(?\:/|\s+#)(?\:unfinish|unfinished)(?\:\s+(.+))?)$:                                                                     @@ This is the MyScene command. It shows pose-order, current finished scenes, most recent pose, what scene is active....                                                                                                     Arguments = %1: player (for staff only)                                                                                                                   ; @break and(strlen(%1),not(u(FUN`is`staff,%#))) =                              @pemit %#=u(FUN`msg,notstaff)                                                                                                                            ; @break and( strlen(%1) , not(u(FUN`is`playerid,                                      setr(PlayerID,u(FUN`get`playerid,objid(pmatch(%1))))))) =              @pemit %#=u(FUN`msg,nosuchplayer,%q<PlayerID>)                                                                                                           ; @pemit %#=u(FUN`display`myscene`top,setr(PlayerID,firstof(%q<PlayerID>,                                   u(FUN`get`playerid,%:))),firstof(objid(pmatch(%1)),%:),finished); @dol/notify [u(FUN`get`scene`playerparticipated,%q<PlayerID>,2)]=@pemit %#=u(FUN`display`myscene`list,##,%q<PlayerID>) ; @wait me=@pemit %#=[u(FUN`display`midline)]
@set u(scenesys)/CMDS`MINE`UNFINISHED=regexp
&CMDS`MOVE u(scenesys)=$^[@+-=!.~]?scene(?\:(?\:/|\s+#)move)\s+(?\:(\d+)/)?(\d+)=(?\:([^ 1234567890]+)\s*)?(\d+)?$:                                                                                                                                @@ Moves poses around. Up/Down or exchanging them out-right. Also can handle 'behind' and 'after'. This side figures out what those end up meaning.                                                                                    Arguments= %1: SceneId, %2: OldPose, %3: MoveID, %4: NewPose/Movecount                                                                                   ; @assert u(FUN`is`scene`id,setr(SceneID,firstof(%1,u(FUN`get`activescene,               u(FUN`get`playerid,%:))))) =                                          @pemit %#=u(FUN`msg,nosuchscene,%1)                                         ; @assert or(u(FUN`is`staff,%:),u(FUN`is`sceneowner,%:)) =                       @pemit u(FUN`msg,notsceneowner,%q<SceneID>)                                 ; @assert and(strlen(%3),strlen(%4))=                                          @include me/include`pose`change_order=%:,%q<SceneID>,%2,%4                 ; th setr(Quantity,firstof(%4,1))                                            ; @switch/regexp %3 =                                                          \(up|\[+\]\) ,                                                                 { @include me/include`pose`move_order=%:,                                    %q<SceneID>,%2,[add(%2,%q<Quantity>)] }                                  , \(down|\[-\]\) ,                                                               { @include me/include`pose`move_order=%:,                                      %q<SceneID>,%2,[sub(%2,%q<Quantity>)] }                                , \(above|before\) ,                                                           { @include me/include`pose`move_order=%:,%q<SceneID>,%2,%4 }               , \(beneath|below|after\) ,                                                    { @include me/include`pose`move_order=%:,%q<SceneID>,%2,inc(%4) }          , @pemit %#=u(FUN`msg,move`notsure)
@set u(scenesys)/CMDS`MOVE=regexp
&CMDS`RECALL u(scenesys)=$^[@+-=!.~]?scene(?\:/|\s+#)(?\:rec|reca|recal|recall|last)(?\:\s+(?\:(\d+)-)?(\d+)(?\:=(.+))?)?$:                                                                                                                                     @@ This is the scene recall command. It recalls poses from the scene as defined.                                                                                                                                                  Arguments= %1: Recall Min, %2: Recall Max, %3: Scene ID                                                                                                  ; @assert u(FUN`is`scene`id,setr(SceneID,firstof(%3,u(FUN`get`activescene,               u(FUN`get`playerid,%:))))) =                                          @pemit %#=u(FUN`msg,nosuchscene,%3)                                                                                                                      ; @include me/include`recall=%1,firstof(%2,u(data`defaultrecall),words(u(FUN`get`playerid`allinscene,%q<SceneID>))),%q<SceneID>
@set u(scenesys)/CMDS`RECALL=regexp
&CMDS`REDESC u(scenesys)=$^[@+-=!.~]?scene(?\:/|\s+#)(?\:redescribe|redesc|desc|describe|description)(?\:\s+(.+?)(?\:=(.+))?)$:                                                                          @@ Sets the description of a scene. This is just a wrapper for +scene/config/set ID/scene_desc=SOMETHING.                                       Arguments= %1: ID, %2: Title                                       ; @inc me/cmds`config`set=%0,%1,scene_desc,%2
@set u(scenesys)/CMDS`REDESC=regexp
&CMDS`REMPLAYER u(scenesys)=$^[@+-=!.~]?scene(?\:/|\s+#)remplayer(?\:\s+(.+?)(?\:=(.+))?)$:                                                                                      @@ This system removes a player from a scene, without checking for the       locks. Only available to staff and scene-owners.                                                                                                          Arguments = %1: Player Ref, %2: Scene ID                                                                                                                  ; @assert setr(PlayerRef,objid(u(FUN`locate,%1)))=                              @pemit %#=u(FUN`msg,nosuchplayer,%q<PlayerRef>)                             ; @assert setr(PlayerID,u(FUN`get`playerid,%q<PlayerRef>))=                     @pemit %#=u(FUN`msg,nosuchplayerid,%q<PlayerID>)                                                                                                         ; th setq(SceneID,firstof(%2,u(FUN`get`scene`recentatloc,objid(%l))))                                                                                     ; @assert or(u(FUN`is`sceneowner,%q<SceneID>,%:),u(FUN`is`staff,%:))=            @pemit %#=u(FUN`msg,cannotremfromscene,%q<SceneID>,%q<PlayerRef>)                                                                                        ; @include me/include`scene`remplayer=%q<SceneID>,objid(%q<PlayerRef>),%:
@set u(scenesys)/CMDS`REMPLAYER=regexp
&CMDS`RESETUP u(scenesys)=$^[@+-=!.~]?scene(?\:/|\s+#)resetup(?\:\s+(.+))$:                                                                                      @@ This is ran by a staffer to resetup a player to use SceneSys! Will succeed even if they were already setup.                                                                                                                 Arguments= %1: dbref/objid/name                                                                                                                           ; @assert u(FUN`is`playerid,setr(PlayerRef,                                             firstof(u(FUN`get`playerid,objid(pmatch(%1))),%1))) =                 @pemit %#=u(FUN`msg,playerid`not,%q<PlayerRef>)                                                                                                          ; @include me/include`player`resetup=%:,%q<PlayerRef>
@set u(scenesys)/CMDS`RESETUP=regexp
&CMDS`RETITLE u(scenesys)=$^[@+-=!.~]?scene(?\:/|\s+#)(?\:retitle|title|rename)(?\:\s+(.+?)(?\:=(.+))?)$:                                                                          @@ Sets the title of a scene. This is just a wrapper for +scene/config/set ID/scene_title=SOMETHING.                                       Arguments= %1: ID, %2: Title                                       ; @inc me/cmds`config`set=%0,%1,scene_title,%2
@set u(scenesys)/CMDS`RETITLE=regexp
&CMDS`SCHEDULE u(scenesys)=$^[@+-=!.~]?scene(?\:/|\s+#)(?\:schedule)(?\:\s(.+))?$:                                                                              @@ This is merely a command to display the current schedule of scenes. With an optional argument for selecting the 'stretch of time' in which to look for a schedule.                                                                                                                                           Arguments= %1: Timeline                                                                                                                                   ; @assert or(u(FUN`is`valid`scheduletimeline,%1),not(strlen(%1)))=              @pemit %#=u(FUN`msg,invalidscheduletimeline,%1)                             ; @include %!/include`schedule`view= %# ,                                                  setr(Days,firstof(u(FUN`get`scheduletimeline,%1),                             u(FUN`get`default`scheduletimeline))),                                        u(FUN`get`scheduletimedays,%q<Days>)
@set u(scenesys)/CMDS`SCHEDULE=regexp
&CMDS`SCHEDULE`ADD u(scenesys)=$^[@+-=!.~]?scene(?\:/|\s+#)(?\:schedule)(?\:/|\s+#)(?\:add)(?\:\s(.+?))=((?s).+)$:                                                                                                                                                     @@ This command adds a scene to the schedule. I takes the time and title as the first argument, and the description as the second.                                                                                                    Arguments= %1: Time and Title, %2: Description                                                                                                            ; @assert u(FUN`is`valid`schedulearg,%1)=                                       @pemit %#=u(FUN`msg,Invalid Scheduling Argument)                            ; @break u(FUN`has`scheduledscene,                                              setr(ScheduleData,u(FUN`get`scheduleaddarg,%1)),%:) =                         @pemit %#=u(FUN`msg,schedule`alreadyhavescenethatday)                       ; @include %!/include`schedule`add=                                            %:,u(FUN`get`playerid,%:),%q<ScheduleData>,%2,u(FUN`get`name,%:)
@set u(scenesys)/CMDS`SCHEDULE`ADD=regexp
&CMDS`SCHEDULE`ADD_HERE u(scenesys)=$^[@+-=!.~]?scene(?\:/|\s+#)(?\:schedule)(?\:/|\s+#)(?\:add/here)(?\:\s(.+?))=((?s).+)$:                                                                                                                                                     @@ This command adds a scene to the schedule with the room at the player's location. I takes the time and title as the first argument, and the description as the second.                                                                                                    Arguments= %1: Time and Title, %2: Description                                                                                                            ; @assert u(FUN`is`valid`schedulearg,%1)=                                       @pemit %#=u(FUN`msg,Invalid Scheduling Argument)                            ; @break u(FUN`has`scheduledscene,                                              setr(ScheduleData,u(FUN`get`scheduleaddarg,%1)),%:) =                         @pemit %#=u(FUN`msg,schedule`alreadyhavescenethatday)                       ; @include %!/include`schedule`add=                                            %:,u(FUN`get`playerid,%:),%q<ScheduleData>,%2,u(FUN`get`name,%:),%l
@set u(scenesys)/CMDS`SCHEDULE`ADD_HERE=regexp
&CMDS`SCHEDULE`DEL u(scenesys)=$^[@+-=!.~]?scene(?\:/|\s+#)(?\:schedule)(?\:/|\s+#)(?\:del)(?\:\s(\d+))$:                                                                                @@ This command deletes a scene from the schedule.                                                                                                        Arguments= %1: Schedule ID                                                                                                                                ; @assert u(FUN`is`valid`scheduleid,%1)=                                        @pemit %#=u(FUN`msg,noscheduleid)                                           ; @assert or(strmatch(u(FUN`get`playerid,%:),elements(                                  u(w`query,get`schedule`fullbyid::|,%1),6,|)),u(FUN`is`staff,%:)) =    @pemit %#=u(FUN`msg,dontownschedule)                                                                                                                     ; @include %!/include`schedule`del=%:,%1
@set u(scenesys)/CMDS`SCHEDULE`DEL=regexp
&CMDS`SCHEDULE`RESCHEDULE u(scenesys)=$^[@+-=!.~]?scene(?\:/|\s+#)(?\:schedule)(?\:/|\s+#)reschedule(?\:\s(\d+))=(.+)$:                                                                                                                                                       @@ This command reschedules a scene to a date, if all conditions are met.                                                                                 Arguments= %1: Schedule ID, %2: Date Argument                                                                                                             ; @assert u(FUN`is`valid`scheduleid,%1)=                                        @pemit %#=u(FUN`msg,noscheduleid)                                                                                                                        ; @assert or(strmatch(u(FUN`get`playerid,%:),elements(                                  u(w`query,get`schedule`fullbyid::|,%1),6,|)),u(FUN`is`staff,%:)) =    @pemit %#=u(FUN`msg,dontownschedule)                                                                                                                     ; @assert or(u(FUN`is`valid`scheduletimeline,%2),not(strlen(%2)))=              @pemit %#=u(FUN`msg,invalidscheduletimeline,%2)                                                                                                          ; @include me/include`schedule`reschedule=%#,%1,%2
@set u(scenesys)/CMDS`SCHEDULE`RESCHEDULE=regexp
&CMDS`SCHEDULE`VIEW u(scenesys)=$^[@+-=!.~]?scene(?\:/|\s+#)(?\:schedule)(?\:/|\s+#)(?\:view)(?\:\s(\d+))$:                                                                               @@ This command simply displays the information on a scene.                  Arguments: %1=Schedule ID                                                    ; @assert u(FUN`is`valid`scheduleid,%1)=                                        @pemit %#=u(FUN`msg,noscheduleid)                                           ; @pemit %#=u(FUN`display`schedule`info,%1)
@set u(scenesys)/CMDS`SCHEDULE`VIEW=regexp
&CMDS`SETUP u(scenesys)=$^[@+-=!.~]?scene(?\:/|\s+#)setup(?\:\s+(.+))?$:                                                                                        @@ This is ran by a player to setup themselves to use SceneSys! An admin can run this with an argument to set up a player or an object for SceneSys. It'll check if the argument exists, and that's it. If you accidentally add an 'exit' or 'room' and the system still has the defaults set - it will still not listen to it, but it will add the entry.                                                                                                    Arguments= %1: dbref/objid/name                                                                                                                          ; @assert [setr(PlayerRef,objid(u(FUN`locate,firstof(%1,%#))))] =               @pemit %#=u(FUN`msg,cantfind,%1)                                           ; @include me/include`player`setup=%:,%q<PlayerRef>
@set u(scenesys)/CMDS`SETUP=regexp
&CMDS`UNDO_REDO u(scenesys)=$^[@+-=!.~]?scene(?\:/|\s+#)(undo|redo|unpose|repose)$:                                                                               @@ Undoes or redoes a pose. In the case of 'undo', their last pose gets set 'ignore'. They cannot undo a pose before that -- and instead must pose again. Redo unsets a previous pose's ignore status. Only can be done if the last pose by that person was set 'ignore'. This assumes current active scene!                                                                                                                                                    Arguments= %1: undo/redo                                                                                                                                  ; @assert setr(SceneID,u(FUN`get`activescene,                                           setr(PlayerID,u(FUN`get`playerid,%:)))) =                             @pemit %#=u(FUN`msg,noactivescene)                                                                                                                       ; @assert setr(LastPoseID,u(w`query,                                                   get`pose`latest`sceneplayer,%q<SceneID>,%q<PlayerID>)) =             @pemit %#=u(FUN`msg,noposebyplayer)                                                                                                                      ; @switch %1=                                                                  re*                                                                          , {                                                                              @assert u(w`query,get`pose`ignore,%q<LastPoseID>) =                            @pemit %#=u(FUN`msg,noundone)                                               ; @include me/include`pose`ignore = %:,%q<LastPoseID>,0                    } ,                                                                        un*                                                                          , {                                                                              @break u(w`query,get`pose`ignore,%q<LastPoseID>) =                             @pemit %#=u(FUN`msg,undolimit,%q<LastPoseID>)                               ; @include me/include`pose`ignore =  %:,%q<LastPoseID>,1                   }
@set u(scenesys)/CMDS`UNDO_REDO=regexp
&COMMAND_LOCK u(scenesys)=Holds the response for failing to be setup and using a command.
@set u(scenesys)/COMMAND_LOCK=no_command
&COMMAND_LOCK`FAILURE u(scenesys)=if(u(FUN`lock`testlock,fn`is`rightversion/1,%#),u(FUN`msg,setup`needed,firstof(%0,%#)),u(FUN`msg,badversion))
&CREDITS u(scenesys)=All rights go to: Mercutio @ MUSH / Oathkeeper @ FinalKingdomMUSH. Email: admin@twilightdays.org -- +scene/help for help!                                                                              !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!                                          This code is best read using width: 78 using MUSHclient, made by a wiz #3-9. !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
&CREDITS`LOGO u(scenesys)=____ ____ ____ _%b%b_ ____ ____ _%b%b%b_ ____ %r\[__%b%b|%b%b%b%b|___ |\\ | |___ \[__%b%b%b\\_/%b%b\[__%b%b%r___\] |___ |___ | \\| |___ ___\]%b%b%b|%b%b%b___\]
&DATA u(scenesys)=Holds all data entries for the scene system.
@set u(scenesys)/DATA=no_command
&DATA`ALWAYSTEL u(scenesys)=1
&DATA`COMMAND_OVERRIDE u(scenesys)=1[@@(SET ME TO 0 AFTER INSTALL, IF YOU DON'T LIKE THE COMMAND OVERRIDES AND WANNA FIGURE IT OUT YOURSELF; AND @SET its OVERRIDE attribute to NO_COMMAND )]
&DATA`DEFAULTLIST u(scenesys)=active paused
&DATA`DEFAULTRECALL u(scenesys)=@@(Set this to a value if you don't want the default amount of recall be 'as many players as have posed in a scene')
&DATA`GAMEPREFIX u(scenesys)=+
@set u(scenesys)=DATA`INSTALL:These are items that you need to set either on your database\, or on important PennMUSH files. getdate.template is required due to the expanded manners in which SceneSys will accept your 'date' format. Please overwrite your PennMUSH's getdate.template with what is found here. %r%rThe database.sql is the full format for SQL. We suggest you import this using PHPMYADMIN. If you do not know what PHPMYADMIN is... we suggest you look into this.%r%rThe items found on ANCESTOR should be set on your ancestor player. If you don't have an ancestor player... well... you should! See \(@\)config of ancestor_player.
@set u(scenesys)/DATA`INSTALL=no_command
&DATA`INSTALL`ANCESTOR u(scenesys)=@@ @TRIG this object's data`install`ancestor attribute to install onto the config(ancestor_player) object! - YES, THIS ATTRIBUTE! ; @dol lattr(me/data`install`ancestor`**)=@cpattr me/##=config(ancestor_player)/[edit(##,DATA`INSTALL`ANCESTOR`,)]
&DATA`INSTALL`ANCESTOR`EMITFORMAT u(scenesys)=speak(&%3,|%4,says\,,SAY_FN,NONE_FN)
&DATA`INSTALL`ANCESTOR`LASTPOSE u(scenesys)=Sets the Header and Footer items to default to 'true' or 'false' (1 or 0), around a pose. See include`lastpose`prepose and include`lastpose`postpose editing them. Or use the POSE/SAY/EMIT/SEMIPOSE-format attributes to prepend %7. We HIGHLY suggest at least one of these is activated in some way or another!
&DATA`INSTALL`ANCESTOR`LASTPOSE`POST u(scenesys)=1
&DATA`INSTALL`ANCESTOR`LASTPOSE`PRE u(scenesys)=1
&DATA`INSTALL`ANCESTOR`POSEFORMAT u(scenesys)=speak(&%3,:%4,says\,,SAY_FN,NONE_FN)
&DATA`INSTALL`ANCESTOR`SAY_FN u(scenesys)=ansi(default(%!/color`quote,+Gray),")[ansi(default(%!/color`speak,#EEEEEE),%0)][ansi(default(%!/color`quote,+Gray),")]
&DATA`INSTALL`ANCESTOR`SAYFORMAT u(scenesys)=speak(&%3,"%4,says\,,SAY_FN,NONE_FN)
&DATA`INSTALL`ANCESTOR`SEMIPOSEFORMAT u(scenesys)=speak(&%3,;%4,says\,,SAY_FN,NONE_FN)
&DATA`INSTALL`DATABASE.SQL u(scenesys)=@@ @trigger this attribute in order to be given the SQL queries that create the tables in the scene/otherwise database. ; @dol lattr(u(scenesys)/data`install`database.sql`)=@pemit %#=%r%r[v(##)]%r%r
@set u(scenesys)/DATA`INSTALL`DATABASE.SQL=no_command
&DATA`INSTALL`DATABASE.SQL`SCENE_COMMENTS u(scenesys)=CREATE TABLE IF NOT EXISTS `scene_comments` (  `comment_id` BIGINT(31) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'Designates the id number of the comment.',  `scene_id` BIGINT(31) UNSIGNED NOT NULL COMMENT 'Designates to what scene the comment belongs',  `pose_id` INT(11) DEFAULT NULL,  `player_id` BIGINT(31) UNSIGNED NOT NULL COMMENT 'Designates who added the comment.',  `Comment` text NOT NULL COMMENT 'The comment!',  PRIMARY KEY (`comment_id`)) ENGINE=MyISAM DEFAULT CHARSET=latin1 AUTO_INCREMENT=1 ;
&DATA`INSTALL`DATABASE.SQL`SCENE_CONFIG u(scenesys)=CREATE TABLE IF NOT EXISTS `scene_config` (  `scene_id` BIGINT(31) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'Identifies the scene',  `timeout_skip` DOUBLE UNSIGNED NOT NULL DEFAULT '2400' COMMENT 'How long, in seconds, until we set a player as skip',  `timeout_pause` DOUBLE UNSIGNED NOT NULL DEFAULT '7200' COMMENT 'How long, in seconds, until we set a scene as paused',  `timeout_unfinished` DOUBLE UNSIGNED NOT NULL DEFAULT '604800' COMMENT 'How long, in seconds, until we set a scene as unfinished',  `scene_lock` VARCHAR(255) NOT NULL DEFAULT '#TRUE' COMMENT 'Identifies the lock of the scene, a player needs to pass',  `scene_title` VARCHAR(60) DEFAULT NULL COMMENT 'Identifies the title of the scene',  `scene_desc` longtext COMMENT 'Describes the scene in plain ascii',  `scene_players` text NOT NULL COMMENT 'Lists the players in the scene at the time of an update',  `scene_state` enum('0','1','2','3') NOT NULL DEFAULT '0' COMMENT 'Identifies the state of the scene. Finished (3), Unfinished (2), Paused (1) or Active (0)',  `scene_ordered` enum('0','1') NOT NULL DEFAULT '0' COMMENT 'Do we keep track of the playerorder? We do anyhow, but do we actually warn people that they posed out of turn?',  `scene_announce` VARCHAR(255) NOT NULL COMMENT 'Announce upon creation?',  `scene_private` enum('0','1') NOT NULL DEFAULT '0' COMMENT 'Is the scene private?', `spam_timer` SMALLINT(2) NOT NULL DEFAULT '4' COMMENT 'Keeps an integer value, for how many poses there can be per 10 seconds.',  `scene_owner` VARCHAR(255) NOT NULL COMMENT 'Identifies the scene''s owner.',  `scene_ctime` datetime NOT NULL COMMENT 'Shows when the scene was created.',  `scene_etime` datetime DEFAULT NULL COMMENT 'Indicates when the scene ended, or was set unfinished.',  PRIMARY KEY (`scene_id`),  KEY `timeout_away` (`timeout_skip`,`timeout_pause`,`timeout_unfinished`),  KEY `scene_state` (`scene_state`), FULLTEXT KEY `scene_title` (`scene_title`,`scene_desc`,`scene_players`)) ENGINE=MyISAM  DEFAULT CHARSET=latin1 AUTO_INCREMENT=1 ;
&DATA`INSTALL`DATABASE.SQL`SCENE_JOURNALS u(scenesys)=CREATE TABLE IF NOT EXISTS `scene_journals` (  `journal_id` BIGINT(31) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'Identifies the journal.',  `player_id` BIGINT(31) NOT NULL COMMENT 'Identifies the poser_id who created the journal.',  `journal_time` datetime NOT NULL COMMENT 'Identifies when when the journal was created.',  `journal_title` VARCHAR(255) NOT NULL COMMENT 'Identifies the title of the journal.',  `journal_lock` VARCHAR(255) NOT NULL DEFAULT '#FALSE' COMMENT 'Identifies who can see the journal. ''#FALSE'' for ''only self''.',  `journal_text` longtext NOT NULL COMMENT 'Contains the contents of the journal.',  `journal_html` longtext NOT NULL COMMENT 'Contains the contents of the journal, in HTML format..',  PRIMARY KEY (`journal_id`)) ENGINE=MyISAM DEFAULT CHARSET=latin1 AUTO_INCREMENT=1 ;
&DATA`INSTALL`DATABASE.SQL`SCENE_PLAYERS u(scenesys)=CREATE TABLE IF NOT EXISTS `scene_players` (  `player_id` BIGINT(31) NOT NULL AUTO_INCREMENT COMMENT 'Identifies the player',  `player_objid` VARCHAR(255) NOT NULL COMMENT 'Identifies the player''s object identity. DBREF:CSECS',  `player_initname` VARCHAR(255) NOT NULL DEFAULT 'Unset' COMMENT 'Designates the player''s initial name.',  `activescene_id` BIGINT(31) DEFAULT NULL COMMENT 'Identifies the scene the poser is active in. Empty if N/A.',  `scenecreate_announce` enum('0','1') NOT NULL DEFAULT '1' COMMENT 'Do they announce a scene starting by default if creating one?',  `bitlevel` enum('1','2','3') NOT NULL DEFAULT '1' COMMENT 'Designates the level of the player. ''1'' for player, ''2'' for ''staff'' and ''3'' for''headwizard''.',  `warnings` SET('newposewhileaway','scenefinish','outofroompose','inroompose') NOT NULL DEFAULT 'newposewhileaway,scenefinish,outofroompose,inroompose' COMMENT 'Indicates what warnings a user wants to listen to.',  `spammer` enum('0','1') NOT NULL DEFAULT '0' COMMENT 'Indicates whether or not someone is a spammer - thus locked from SceneSys.',  `setup` enum('0','1') NOT NULL DEFAULT '1' COMMENT 'Claims whether or not a player is setup for the system.',  PRIMARY KEY (`player_id`),  UNIQUE KEY `player_objid_2` (`player_objid`)) ENGINE=MyISAM  DEFAULT CHARSET=latin1 AUTO_INCREMENT=1 ;
&DATA`INSTALL`DATABASE.SQL`SCENE_POSERS u(scenesys)=CREATE TABLE IF NOT EXISTS `scene_posers` (  `poser_playerid` VARCHAR(255) NOT NULL DEFAULT '#-1' COMMENT 'Identifies the poser in the scene',  `poser_away` enum('0','1') NOT NULL DEFAULT '0' COMMENT 'Identifies the poser as away',  `poser_skip` enum('0','1') NOT NULL DEFAULT '0' COMMENT 'Identifies the poser as to ''be skipped''',  `scene_id` BIGINT(20) UNSIGNED NOT NULL COMMENT 'Identifies the scene the poser is in',  `last_activity` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT 'Keeps track of when the player was last active in this scene.',  PRIMARY KEY (`poser_playerid`,`scene_id`)) ENGINE=MyISAM DEFAULT CHARSET=latin1;
&DATA`INSTALL`DATABASE.SQL`SCENE_POSES u(scenesys)=CREATE TABLE IF NOT EXISTS `scene_poses` (  `pose_id` BIGINT(31) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'Identifies the pose uniquely',  `order_id` BIGINT(31) UNSIGNED DEFAULT '0' COMMENT 'Identifies the pose per scene',  `scene_id` BIGINT(31) UNSIGNED NOT NULL COMMENT 'Identifies the scene the pose belongs to',  `owner_id` BIGINT(31) UNSIGNED NOT NULL COMMENT 'Identifies the owner of the scene, at the time of the pose',  `poser_id` BIGINT(31) UNSIGNED NOT NULL DEFAULT '1' COMMENT 'Identifies the poser of the pose',  `poser_name` VARCHAR(255) CHARACTER SET latin1 NOT NULL COMMENT 'Name of character at the time of the pose',  `pose_time` datetime NOT NULL COMMENT 'The time at which the pose/message was created or last edited ',  `pose_penn` longtext CHARACTER SET latin1 COMMENT 'The body of the pose in ansi text',  `pose_room` VARCHAR(255) CHARACTER SET latin1 DEFAULT NULL COMMENT 'The database reference number of the room in which the pose was made',  `pose_room_name` VARCHAR(255) CHARACTER SET latin1 DEFAULT NULL COMMENT 'The name of the room the pose was made in at the time of the pose',  `ignore` enum('0','1') CHARACTER SET latin1 NOT NULL DEFAULT '0' COMMENT 'Do we ignore this pose?',  `sysevent` VARCHAR(255) CHARACTER SET latin1 DEFAULT NULL COMMENT 'Was there a system event? SYSEVENT | English representation.',  `comment` text CHARACTER SET latin1 COMMENT 'Comment on a pose or system event.',  PRIMARY KEY (`pose_id`),  UNIQUE KEY `COMPOSITE` (`scene_id`,`order_id`),  KEY `pose_id` (`pose_id`,`order_id`,`scene_id`),  FULLTEXT KEY `pose_penn` (`pose_penn`)) ENGINE=MyISAM  DEFAULT CHARSET=ascii COLLATE=ascii_bin AUTO_INCREMENT=1 ;
&DATA`INSTALL`DATABASE.SQL`SCENE_RELATIONSHIPS u(scenesys)=CREATE TABLE IF NOT EXISTS `scene_relationships` (  `GLOBID` INT(11) NOT NULL AUTO_INCREMENT COMMENT 'The global id',  `RECURSEID` INT(11) DEFAULT NULL COMMENT 'Points at a global id - forming a relationship with it of being its child.',  `PLOTNAME` VARCHAR(255) DEFAULT NULL COMMENT 'Name of the plot',  `PLOTDESC` VARCHAR(255) DEFAULT NULL COMMENT 'Description of the plot',  `SCENEID` INT(11) DEFAULT NULL COMMENT 'The ID of the scene, if applicable.',  PRIMARY KEY (`GLOBID`)) ENGINE=MyISAM DEFAULT CHARSET=latin1 AUTO_INCREMENT=1 ;
&DATA`INSTALL`DATABASE.SQL`SCENE_SCHEDULE u(scenesys)=CREATE TABLE IF NOT EXISTS `scene_schedule` (  `id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'Schedule ID',  `time` datetime NOT NULL COMMENT 'Time and Day',  `title` VARCHAR(255) NOT NULL COMMENT 'Scene Title',  `description` text CHARACTER SET ascii COLLATE ascii_bin NOT NULL COMMENT 'Scene Description',  `room` VARCHAR(255) DEFAULT NULL COMMENT 'Room the scene is scheduled to take place in - optional.',  `player_id` BIGINT(31) NOT NULL COMMENT 'Who scheduled the scene',  `name` VARCHAR(255) NOT NULL,  PRIMARY KEY (`id`)) ENGINE=MyISAM  DEFAULT CHARSET=latin1 AUTO_INCREMENT=1 ;
&DATA`INSTALL`DATABASE.SQL`SCENE_TAGS u(scenesys)=CREATE TABLE IF NOT EXISTS `scene_tags` (  `tag_id` BIGINT(31) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'Identifies the tag',  `poser_id` BIGINT(31) UNSIGNED NOT NULL DEFAULT '1' COMMENT 'Identifies the creator of the tag',  `scene_id` BIGINT(31) UNSIGNED NOT NULL COMMENT 'Identifies the scene the tag applies to',  `tag` VARCHAR(255) NOT NULL COMMENT 'Identifies the tag by a name',  PRIMARY KEY (`tag_id`),  UNIQUE KEY `TAG_TO_SCENE` (`tag_id`,`scene_id`),  FULLTEXT KEY `tag` (`tag`)) ENGINE=MyISAM DEFAULT CHARSET=latin1 AUTO_INCREMENT=1 ;
&DATA`INSTALL`DATABASE.SQL`SET u(scenesys)=SET SQL_MODE="NO_AUTO_VALUE_ON_ZERO";
&DATA`INSTALL`GETDATE.TEMPLATE u(scenesys)=@@ @trigger this attribute in order to be given the exact info you should put into your GETDATE.TEMPLATE ;   @pemit %#=%r%r[u(data`install`getdate.template`penn)]%r%r
@set u(scenesys)/DATA`INSTALL`GETDATE.TEMPLATE=no_command
&DATA`INSTALL`GETDATE.TEMPLATE`PENN u(scenesys)=\%a \%b \%d \%H:\%M:\%S \%Y%r\%a \%b \%d \%H:\%M:\%S%r\%b \%d \%H:\%M:\%S \%Y%r\%b \%d \%H:\%M:\%S%r\%B \%d \%H:\%M:\%S%r\%B \%d \%H:\%M:\%S \%Y%r\%a \%b \%d \%H:\%M \%Y%r\%a \%b \%d \%H:\%M%r\%b \%d \%H:\%M \%Y%r\%b \%d \%H:\%M%r\%B \%d \%H:\%M%r\%B \%d \%H:\%M \%Y%r\%b \%d \%Y%r\%b \%d%r\%B \%d \%Y%r\%B \%d%r\%Y-\%m-\%d \%H:\%M:\%S%r\%m \%d \%Y%r\%m \%d%r\%m \%d \%H:\%M \%Y%r\%m \%d \%H:\%M:\%S \%Y
&DATA`INSTALLED u(scenesys)=0
&DATA`LISTENROOM u(scenesys)=[pemit(%1,Please tell your staffer to set up scenesys properly. Point them to %!/LISTEN`SENDER and %!/DATA`LISTENROOM please. Thank you.)]#-1
&DATA`LISTENTO u(scenesys)=PLAYER THING
&DATA`LISTENTO`COMMENT u(scenesys)=What types do we listen to? Valid options: player thing exit room
&DATA`MAX u(scenesys)=
&DATA`MAX`IDLETODEACTIVATE u(scenesys)=8200
&DATA`MAXBUFFER u(scenesys)=[div(strlen(repeat(-,100000)),2)][@@(This is a bit funky\, and requires knowledge of how PennMUSH works with its command buffer\, and function buffer. Leave this alone. DATA`MAXBUFFER when evaluated is the command-buffer! A buffer should /never/ be an uneven number.)]
&DATA`MAXSMARTSECS u(scenesys)=2851200
&DATA`MINIMUMVERSION u(scenesys)=1.8.5 patchlevel 4
&DATA`MINPOSEWORDS u(scenesys)=10
&DATA`MINPOSEWORDS`COMMENT u(scenesys)=How many words should be in a capture by the SceneSys's listen to asume it is a pose? This is to remove movement chatter - which is extremely hard to ignore.
&DATA`MINSMARTSECS u(scenesys)=1200
&DATA`MSGPREFIX u(scenesys)=\[[ansi(hw,SceneSys)]\]
&DATA`MYSCENECOUNT u(scenesys)=5
&DATA`RECENTSCENESECS u(scenesys)=21000
&DATA`SCANINTERVAL u(scenesys)=5
&DATA`SCANINTERVAL`COMMENT u(scenesys)=Per how many seconds do we do an entire system's check? This is for the main loop.
&DATA`SCHEDULEBOARD u(scenesys)=2
&DATA`SCHEDULEBOARD_DB u(scenesys)=#47
&DATA`SCHEDULEDEFAULT u(scenesys)=10[@@(Amount of days go here.)]
&DATA`SQL u(scenesys)=Holds the constant SQL information for this system. On a default install, stay off of these!
&DATA`SQL`DATABASE u(scenesys)=scene
&DATA`SQL`TABLE u(scenesys)=Contains the sql tables.
&DATA`SQL`TABLE`COMMENTS u(scenesys)=scene_comments
&DATA`SQL`TABLE`COMMENTS`COMMENT u(scenesys)=Contains scene-comments for poses, or scenes in general.
&DATA`SQL`TABLE`CONFIG u(scenesys)=scene_config
&DATA`SQL`TABLE`CONFIG`COMMENT u(scenesys)=Per scene configuration and resulting information, such as title and lock.
&DATA`SQL`TABLE`JOURNALS u(scenesys)=scene_journals
&DATA`SQL`TABLE`JOURNALS`COMMENT u(scenesys)=Contains player journals.
&DATA`SQL`TABLE`PLAYERS u(scenesys)=scene_players
&DATA`SQL`TABLE`PLAYERS`COMMENT u(scenesys)=Players && Scene table. What players are in what scenes, and what is their status in that scene?
&DATA`SQL`TABLE`POSER u(scenesys)=scene_posers
&DATA`SQL`TABLE`POSER`COMMENT u(scenesys)=Information about a poser. Holds OBJID information.
&DATA`SQL`TABLE`POSES u(scenesys)=scene_poses
&DATA`SQL`TABLE`POSES`COMMENT u(scenesys)=Holds all the poses for scenes, as well as who posed it as per 'poser'. Also allows for system messages and pose-comments.
&DATA`SQL`TABLE`RELATIONSHIPS u(scenesys)=scene_relationships
&DATA`SQL`TABLE`RELATIONSHIPS`COMMENT u(scenesys)=Contains a recursive relationship of scene-to-plot and plot-to-plot.
&DATA`SQL`TABLE`SCHEDULE u(scenesys)=scene_schedule
&DATA`SQL`TABLE`SCHEDULE`COMMENT u(scenesys)=Contains the scheduling information for scenes.
&DATA`SQL`TABLE`TAGS u(scenesys)=scene_tags
&DATA`SQL`TABLE`TAGS`COMMENT u(scenesys)=Holds tags, and displays what scenes they apply to, and who added the tag for /that/ scene.
&DATA`TELCOMMAND u(scenesys)=+tel/loc
&DATA`URL u(scenesys)=This contains your website's information. It is important to edit this!
&DATA`URL`BASE u(scenesys)=finalkingdom.net/scene/
&DATA`URL`VIEW u(scenesys)=view.php?id=
&DESCRIBE u(scenesys)=u(credits`logo)%r%r%r[v(credits)]
@set u(scenesys)/DESCRIBE=no_command visual prefixmatch public nearby
&FN u(scenesys)=Holds all the SceneSys functions.
@set u(scenesys)/FN=no_command
&FUN`DISPLAY u(scenesys)=Holds the SceneSys functions that deal with displaying information.
&FUN`DISPLAY`CMDTAG u(scenesys)=switch(config(pueblo),Yes,tagwrap(a xch_cmd="%0",strfirstof(%1,%0)),%1)
&FUN`DISPLAY`CONFIG u(scenesys)=u(FUN`display`header,%bConfig[condall(%0,: %0,%1,%b-%bScene %1)]%b)%r[setq(Border,ansi(hb,|))][iter(Setting:~[if(%1,Setting,Default)]:~Explanation:|[u(FUN`get`config,%0,%1)],align(20 1. 24 1. [sub(width(%#),50)],first(%i0,~),%q<Border>,switch(first(rest(%i0,~),~),?*,if(strmatch(rest(rest(%i0,~),~),*second*),#$ ([timestring(#$)]),#$),NULL),%q<Border>,rest(rest(%i0,~),~)),|,%r[u(FUN`display`midline)]%r)]%r[u(FUN`display`footer)]
&FUN`DISPLAY`FOOTER u(scenesys)=firstof([footer(%0,%1,%2)],center(\[%0\],78,-))
&FUN`DISPLAY`HEADER u(scenesys)=firstof([header(%0,%1,%2[@@(Sent to - if not %#)])],center(\[%0\],78,-))
&FUN`DISPLAY`HEADER`LIST u(scenesys)=ID: %b%b[ljust(Title,sub(width(%#),57))] Owner[space(11)]Start Date:%b%b%bEnd Date:%b%b%bOrdered:
&FUN`DISPLAY`HELP u(scenesys)=switch(%0,index,u(FUN`display`help`table,u(FUN`get`help`validoptions)),*,if(u(FUN`is`helptopic,%0),u(FUN`display`help`topic,%0),u(FUN`msg,nohelpfile,%0)))
&FUN`DISPLAY`HELP`TABLE u(scenesys)=u(FUN`display`header,\[ SCENESYS: HELP MENU \])%r[table(iter(%0,[after(%i0,MSG`HELP`)]),18,width(%#))]%r[u(FUN`display`footer)]
&FUN`DISPLAY`HELP`TOPIC u(scenesys)=u(FUN`display`header,\[ SCENESYS: HELP: %0 \])%r[u(msg`help`[edit(%0,%b,_)])]%r[u(FUN`display`footer)]
&FUN`DISPLAY`LISTITEM u(scenesys)=switch(%0,header,u(FUN`display`header,< [ansi(hw,Listing [lcstr(itemize(%1))] scenes)] >)%r[u(FUN`display`header`list)],footer,u(FUN`display`footer),u(FUN`display`listitem`item,%0))
&FUN`DISPLAY`LISTITEM`ITEM u(scenesys)=setq(SceneInfo,u(w`query,get`scene`listinfo::|,%0))[align(5 [setr(Width,sub(width(%#),57))] 15 13 11 3,ansi([switch(%q<SceneInfo>,*|0,hg,*|1,hy,*|2,u,*|3,hw,n)],%0),left(firstof(first(%q<SceneInfo>,|),None),%q<Width>),left(u(FUN`get`playername`from`playerid,extract(%q<SceneInfo>,2,1,|)),15),first(extract(%q<SceneInfo>,3,1,|)),switch(first(extract(%q<SceneInfo>,4,1,|)),0000-00-00,Unfinished,firstof(#$,Unfinished)),switch(extract(%q<SceneInfo>,5,1,|),0,No,1,Yes,?))]
&FUN`DISPLAY`MIDLINE u(scenesys)=firstof([midline(%0,%1,%2)],[footer(%0,%1,%2)],center(\[%0\],78,-))
&FUN`DISPLAY`MYSCENE u(scenesys)=[u(FUN`display`header,< MyScene: [ansi(hw,name(%1))] >)]%r[align([sub(div(width(%#),2),4)] 2 [sub(div(width(%#),2),4)],ansi(hw,Active Scene): [switch(u(FUN`get`activescene,%0),?*,u(FUN`display`cmdtag,+scene #$,ansi(hru,##$)),ansi(hr,None))],,Has been in [ansi(hw,words(u(FUN`get`scene`playerparticipated,%0,3[@@(complete)])))] completed scenes.)]%r[u(FUN`display`midline,< [ansi(hw,Scenes current open and part of)] >)]%r[iter(u(FUN`get`scene`playerparticipated,%0,if(%2,3[@@(complete)],1[@@(paused)] 0[@@(active)])),u(FUN`display`myscene`list,%i0,%0),,%r[u(FUN`display`midline)]%r)]%r[u(FUN`display`footer,%bFor help: [ansi(hw,+scene/help)][if(u(FUN`get`scene`playerparticipated,%0,2),%b- [u(FUN`display`cmdtag,+scene/mine/unfinished)] for unfinished scenes)]%b)]
&FUN`DISPLAY`MYSCENE`LIST u(scenesys)=align(5 [sub(width(%#),6)],u(FUN`display`cmdtag,scene/activate %0,#%0),u(FUN`display`cmdtag,scene/info %0,[left(ljust(firstof(u(FUN`get`config`tables,scene_title,%0),No Title.),sub(width(%#),43)),sub(width(%#),43))]) [ansi(hw,Your last pose)]: [strfirstof(u(w`query,get`pose`info,pose_time,u(w`query,get`pose`id`last`from`player_id_and_scene,%1,%0)),None Yet)]%r[ansi(hw,Status)]: [setr(SceneStatus,u(FUN`get`scene`status,%0))] and [switch(u(FUN`is`scene`ordered,%0),1,enforces pose-order.,switch(%q<SceneStatus>,Finished,did,does) not enforce pose-order.)])
&FUN`DISPLAY`MYSCENE`TOP u(scenesys)=[u(FUN`display`header,< MyScene: [ansi(hw,name(%1))] >)]%r[align([sub(div(width(%#),2),4)] 2 [sub(div(width(%#),2),4)],ansi(hw,Active Scene): [switch(u(FUN`get`activescene,%0),?*,u(FUN`display`cmdtag,+scene #$,ansi(hru,##$)),ansi(hr,None))],,Has been in [ansi(hw,words(u(FUN`get`scene`playerparticipated,%0,3[@@(complete)])))] completed scenes.)]%r[u(FUN`display`midline,< [ansi(hw,Scenes current open and part of)] >)]
&FUN`DISPLAY`PLAYERINFO u(scenesys)=u(FUN`display`header,< My Info: [ansi(hw,u(FUN`get`playername`from`playerid,%0) (%0))] >)%r%r[u(FUN`display`footer)]
&FUN`DISPLAY`POSEORDER u(scenesys)=>> DISPLAY POSE ORDER: %0 is the scene <<
&FUN`DISPLAY`RECALLPOSE u(scenesys)=u(FUN`display`header,%b[ansi(hw,In '[first(u(w`query,get`pose`tableinfo,pose_room_name,%0),-)]'\, [u(w`query,get`pose`tableinfo,poser_name,%0)] posed)]: \( OrderID: #[u(w`query,get`pose`tableinfo,order_id,%0)] [null(ansi(hw,(PoseID: %0) \[[u(w`query,get`pose`tableinfo,pose_time,%0)]\]))]\)%b)%r[u(w`query,get`pose`tableinfo,pose_penn,%0)][switch(%1,%2,%r[u(FUN`display`footer)],)]
&FUN`DISPLAY`ROOMSCENE u(scenesys)=localize(if( setr(SceneList,u(FUN`get`scene`recentatloc,objid(%0),1)) , < [ansi(hg,ACTIVE SCENE[switch(words(%q<SceneList>),>1,S)])]: [itemize(iter(%q<SceneList>,[u(FUN`display`cmdtag,+scene %i0,%i0)]))] > ))
@set u(scenesys)/FN`DISPLAY`ROOMSCENE=visual public
&FUN`DISPLAY`SCEDULE u(scenesys)=
&FUN`DISPLAY`SCEDULE`SCENE u(scenesys)=
&FUN`DISPLAY`SCEDULE`SCENE`TZ u(scenesys)=elements(%q<FullInfo>,2,|)||
&FUN`DISPLAY`SCENEINFO u(scenesys)=u(FUN`display`header,< Sceneinfo: [ansi(hw,Scene #%0)] >)%r[iter(scene_ctime:Creation_date scene_title:Title scene_desc:Description timeout_skip:Time_until_order_skip timeout_pause:Time_until_the_scene_is_paused timeout_unfinished:Time_until_the_scene_is_set_as_unfinished,ansi(hw,rest(edit(%i0,_,%b),:)):%b[firstof(reswitch([u(FUN`get`config`tables,first(%i0,:),%0)],^\\d+$,timestring(#$),#$),Not Set.)]%r[u(FUN`display`midline)],,%r)]%r[u(FUN`display`sceneinfo`playersinscene,%0, [u(FUN`get`config`tables,first(scene_owner,:),%0)]  )]%r[rjust(ansi(hw,Total poses):%b,sub(width(%#),8))]%b[center(u(w`query,get`pose`count`inscene,%0),7)]%r[u(FUN`display`midline)]%r[ansi(hw,Status)]: [setr(SceneStatus,u(FUN`get`scene`status,%0))] and [switch(u(FUN`is`scene`ordered,%0),1,enforces pose-order.,switch(%q<SceneStatus>,Finished,did,does) not enforce pose-order.)]%r[u(FUN`display`midline)]%r[ansi(hw,URL)]: [if(pueblo(%#),tag(a))]http://[v(data`url`base)][v(data`url`view)]%0[if(pueblo(%#),endtag(a))]%r[u(FUN`display`footer)]
&FUN`DISPLAY`SCENEINFO`PLAYERSINSCENE u(scenesys)=align(20 [sub(width(%#),39)] 9 7,ansi(hw,Players):,ansi(hw,As):,ansi(hw,Status):,ansi(hw,Poses):)%r[if(setr(PlayerIDsInScene,setunion(u(FUN`get`playerid`allinscene,%0),u(FUN`get`playerid`allinposes,%0))),iter(%q<PlayerIDsInScene>,align(20 [sub(width(%#),39)] 9 -7,first(setr(PlayerPoses,firstof(ansi(switch(%1,%i0,gu,),u(FUN`get`playername`posesinscene,%0,%i0,:|)),ansi(switch(%1,%i0,gu,),[u(FUN`get`playername`from`playerid,%i0)]) )),|),firstof(itemize(rest(%q<PlayerPoses>,|),|),Themselves),u(FUN`display`sceneinfo`playersinscene`status,%i0,%0),u(w`query,get`pose`count`inscene`fromplayer,%i0,%0)),,%r),u(FUN`get`playername`from`playerid,u(FUN`get`config`tables,scene_owner,%0)))]
&FUN`DISPLAY`SCENEINFO`PLAYERSINSCENE`STATUS u(scenesys)=switch(u(FUN`is`inscene,%0,%1):[isdbref(u(FUN`get`playerobjid,%0))]:[u(FUN`lock`testlock,u(FUN`get`scene`lock,%1),u(FUN`get`playerobjid,%0))],*:0:*,Retired,0:1:1,Left,0:1:0,Kicked,1:*:1,[switch(u(FUN`get`player`status`inscene,%0,%1),1,Skip,0,Active,ERROR! >[stext(0)]<)],ERROR! >[stext(0)]<)
&FUN`DISPLAY`SCHEDULE u(scenesys)=u(FUN`display`header,< Current Schedule >)%r[setq(Start,first(%0,|))][map(fn`display`schedule`day,lnum(u(FUN`get`scheduletimedays,%0)),,%r)]%r[u(FUN`display`footer)]
&FUN`DISPLAY`SCHEDULE`DAY u(scenesys)=[setq(Day,convsecs(add(convtime(%1),mul(%0, stringsecs(1d) ))))][setq(ScheduleList,u(w`query,get`schedule`ids,u(FUN`sql`timeformat,convtime(replace(%q<Day>,4,00:00:00))),u(FUN`sql`timeformat,convtime(replace(%q<Day>,4,23:59:59)))))][u(FUN`display`midline,< [ansi(hc,elements(%q<Day>,1 2 3 5))][if(strlen(%q<ScheduleList>),: [switch(words(%q<ScheduleList>),1,#$ scene,#$ scenes)],: None)] >)][map(fn`display`schedule`scene,%q<ScheduleList>,,)]
&FUN`DISPLAY`SCHEDULE`INFO u(scenesys)=setq(FullInfo,u(w`query,get`schedule`fullbyid::|,%0))[u(FUN`display`header,< [ansi(hw,Schedule ID: %0)] - [first(extract(%q<FullInfo>,2,1,|))] >)]%r[align(34 -8 [config(player_name_len)] >[sub(width(%#),8,add(34,config(player_name_len),3))],u(%=`title),u(%=`time),u(%=`player),u(%=`room))][if(strlen(elements(%q<FullInfo>,5,|)),%r[u(FUN`display`header)]%r[center(In [ansi(hw,name(elements(%q<FullInfo>,5,|)))],78)])]%r[u(FUN`display`midline,< [ansi(hw,Description)] >)]%r[extract(%q<FullInfo>,4,1,|)]%r[u(FUN`display`midline,< In Other Timezones >)]%r[lalign(-25 -25 -25,iter(EST Personal GMT, %i0%r[switch( [timefmt($a $H:$M ($I:$M $p),convtime([extract(%q<FullInfo>,2,1,|)]),switch(%i0,Personal,get(%#/TZ),EST,America/New_York,%i0) )], #-1*,No TZ Attribute Set,#$ )] ,,|),|)]%r[u(FUN`display`footer)]
&FUN`DISPLAY`SCHEDULE`INFO`PLAYER u(scenesys)=firstof([name(u(FUN`get`playerobjid,elements(%q<FullInfo>,6,|)))],[u(FUN`get`playername`from`playerid,elements(%q<FullInfo>,6,|))])
&FUN`DISPLAY`SCHEDULE`INFO`ROOM u(scenesys)=if(strlen(elements(%q<FullInfo>,5,|)),u(FUN`tel,elements(%q<FullInfo>,5,|),No Room Set)
&FUN`DISPLAY`SCHEDULE`INFO`TIME u(scenesys)=extract(last(elements(%q<FullInfo>,2,|)),1,2,:)
&FUN`DISPLAY`SCHEDULE`INFO`TITLE u(scenesys)=elements(%q<FullInfo>,3,|)
&FUN`DISPLAY`SCHEDULE`SCENE u(scenesys)=%r[setq(FullInfo,u(w`query,get`schedule`fullbyid::|,%0))][align(4 30 -8 [config(player_name_len)] >[sub(width(%#),8,add(4,30,config(player_name_len),4))],u(%=`id),u(%=`title),u(%=`time),u(%=`player),u(%=`tz))]
&FUN`DISPLAY`SCHEDULE`SCENE`ID u(scenesys)=u(FUN`display`cmdtag,+scene/schedule/view [first(%q<FullInfo>,|)],first(%q<FullInfo>,|))
&FUN`DISPLAY`SCHEDULE`SCENE`PLAYER u(scenesys)=firstof([name(u(FUN`get`playerobjid,elements(%q<FullInfo>,6,|)))],[u(FUN`get`playername`from`playerid,elements(%q<FullInfo>,6,|))])
&FUN`DISPLAY`SCHEDULE`SCENE`ROOM u(scenesys)=if(strlen(elements(%q<FullInfo>,5,|)),u(FUN`tel,elements(%q<FullInfo>,5,|),No Room Set)
&FUN`DISPLAY`SCHEDULE`SCENE`TIME u(scenesys)=extract(last(elements(%q<FullInfo>,2,|)),1,2,:)
&FUN`DISPLAY`SCHEDULE`SCENE`TITLE u(scenesys)=elements(%q<FullInfo>,3,|)
&FUN`DISPLAY`SCHEDULE`SCENE`TZ u(scenesys)=firstof(timefmt($I:$M $p $Z,convtime(elements(%q<FullInfo>,2,|)),get(%#/TZ)),No TZ Attr. Set)
&FUN`EXITPAIR u(scenesys)=filter(#lambda/match(home(\%0),loc(%0)),entrances(home(%0)))[@@(Takes an exit(out)\, goes out and will check what exit(in) goes back to the room exit(out) is in.)]
&FUN`FILTER u(scenesys)=Holds the SceneSys functions that filter out (relevant) information.
&FUN`FILTER`CREATIONLINEDOUBLES u(scenesys)=regeditall(%0,(\\xa0|^)(\[^\\xa0\]+:)(\[^\\xa0\]*)(?=.*\\2),,^\\xa0+|\\xa0+$,)
&FUN`FILTER`CREATIONLINEDOUBLES`CREDIT u(scenesys)=Credit for this filter goes to Walker@M*U*S*H - always fun to brainstorm over how to do these things. So many solutions to the same problem... See --> http://community.pennmush.org/blog/mercutio/2010/one-problem-many-solutions <--
&FUN`FILTER`CREATIONLINEERRORS u(scenesys)=[regeditall(%0,v(fn`is`validcreationline`regexp),)]
&FUN`GET u(scenesys)=Holds the SceneSys functions that deal in retrieving pure information. A lot of these are self-explainatory by name. In future versions, the 'expected input' may be added under the COMMENT substructure. (WIP)
&FUN`GET`ACTIVESCENE u(scenesys)=u(w`query,get`activescene,%0)
&FUN`GET`BBPOST u(scenesys)=element(get(v(data`scheduleboard_db)/mess_lst),after(grep(v(data`scheduleboard_db),HDR*,Schedule #%0:),HDR_),%b)
&FUN`GET`BITLEVEL u(scenesys)=if(u(FUN`is`staff,%0),2,1)
&FUN`GET`CONFIG u(scenesys)=if(%1,[iter(if(%0,u(w`query,get`config`specific:|:~,%0),u(w`query,get`config`all:|:~,%0)),[first(%i0,~)]~[firstof(u(w`query,get`config`anytable,first(%i0,~),scene_id,%1),first(rest(%i0,~),~))]~[rest(rest(%i0,~),~)],|,|)],[u(w`query,get`config[if(%0,`specific,`all)]:|:~,%0)])
&FUN`GET`CONFIG`TABLES u(scenesys)=u(w`query,get`config`tableinscene,%0,%1)
&FUN`GET`CREATIONLINE u(scenesys)=if(not(u(FUN`is`validcreationline,%0)),#-1 INVALID CREATIONLINE,u(FUN`get`creationline`result,%0)
&FUN`GET`CREATIONLINE`DO u(scenesys)=null(regeditall(%0,v(fn`is`validcreationline`regexp),[setq(FieldValue,setunion(%q<FieldValue>,$<FIELD>|$<VALUE>$<VALUEQ>,[chr(160)],,[chr(160)]))]))[setq(TableValue,iter(edit(setdiff(u(w`query,get`table,v(data`sql`table`config),%%),scene_id scene_owner scene_ctime scene_etime scene_state scene_players),scene_,),%i0))][setr(FirstValue,squish(iter(%q<FieldValue>,grab(%q<TableValue>,first(%i0,|)*),chr(160))))][setr(OutPutRegister,setdiff(iter(%q<FieldValue>,first(%i0,|),chr(160)),%q<FirstValue>))]
&FUN`GET`CREATIONLINE`RESULT u(scenesys)=null(u(FUN`get`creationline`do,%0))%q<FieldValue>
&FUN`GET`CREATIONLINE`USELESS u(scenesys)=if(u(FUN`get`creationline`result,%0)%q<OutPutRegister>,%q<OutPutRegister>,0)
&FUN`GET`DATABASE u(scenesys)=default(me/data`sql`database,scene)
&FUN`GET`DEFAULT u(scenesys)=
&FUN`GET`DEFAULT`SCHEDULETIMELINE u(scenesys)=time()|[convsecs(add(secs(),stringsecs(dec(u(data`scheduledefault))d)))]
&FUN`GET`FULLTABLE u(scenesys)=if( match(config players poser poses tags,%0) , [if(u(data`sql`database),[u(data`sql`database)].,scene.)][default(me/data`sql`table`%0,scene_[lcstr(%0)])] , #-1 INVALID TABLE )
&FUN`GET`HELP u(scenesys)=Gets help-related files.
&FUN`GET`HELP`VALIDOPTIONS u(scenesys)=filter(#lambda/if\(u\(fn`is`staff\,%#\)\,1\,not\(match\(%%0\,*wiz*\)\)\),lattr(me/msg`help`**))
&FUN`GET`LASTPOSETIME u(scenesys)=
&FUN`GET`LASTPOSETIME`PLAYER u(scenesys)=u(w`query,get`pose`info,pose_time,u(w`query,get`pose`id`last`from`player_id_and_scene,%0,%1))
&FUN`GET`LIST u(scenesys)=u(w`query,get`scenes`from`status,%0,firstof(%1,0))
&FUN`GET`LIST`ROOMRESTRICT u(scenesys)=u(w`query,get`scenes`from`status_room,%0,firstof(%1,0))
&FUN`GET`NAME u(scenesys)=name(%0)
&FUN`GET`OBJIDS_NOTINROOM u(scenesys)=filterbool(#lambda/not(match(loc(%1),loc(%%0))),u(FUN`get`playerobjid,u(FUN`get`playerid`allinscene,%0)))
&FUN`GET`PLAYER u(scenesys)=
&FUN`GET`PLAYER`STATUS u(scenesys)=
&FUN`GET`PLAYER`STATUS`INSCENE u(scenesys)=u(w`query,get`status`from`posers,%1,%0)
&FUN`GET`PLAYERID u(scenesys)=u(w`query,get`playerid`from`objid,objid(%0))
&FUN`GET`PLAYERID`ALLINPOSES u(scenesys)=u(w`query,get`playerid`from`sceneposes,%0)
&FUN`GET`PLAYERID`ALLINSCENE u(scenesys)=u(w`query,get`playerid`from`posers,%0)
&FUN`GET`PLAYERID`ANNOUNCETO u(scenesys)=u(w`query,get`playerid`announceto)
&FUN`GET`PLAYERNAME u(scenesys)=
&FUN`GET`PLAYERNAME`FROM u(scenesys)=
&FUN`GET`PLAYERNAME`FROM`PLAYERID u(scenesys)=if(setr(Match,pmatch(extract(setr(PlayerInfo,u(w`query,get`player`info::|,%0)),2,1,|))),u(FUN`get`name,%q<Match>),extract(%q<PlayerInfo>,3,1,|))
&FUN`GET`PLAYERNAME`POSESINSCENE u(scenesys)=u(w`query,get`player`namesinscene%2,%0,%1)[@@(%0: Scene\, %1: Player_ID)]
&FUN`GET`PLAYEROBJID u(scenesys)=u(w`query,get`objid`from`playerid,%0)
&FUN`GET`RECALLIDS u(scenesys)=switch(strlen(%1):[strlen(%2)],*:0,ERROR!,0:*,u(w`query,get`pose`id`recallrev,%0,0\,%2),u(w`query,get`pose`id`recall,%0,%1,%2))
&FUN`GET`RECALLIDS`PREPARE u(scenesys)=setq(i,0)[switch(strlen(%1):[strlen(%2)],*:0,ERROR!,0:*,u(w`prepare,get`pose`id`recallrev,%0,0\,%2),u(w`prepare,get`pose`id`recall,%0,%1,%2))]
&FUN`GET`SCENE u(scenesys)=
&FUN`GET`SCENE`LASTVALIDACTIVE u(scenesys)=u(w`query,get`scene`lastvalidactive,%0)
&FUN`GET`SCENE`LOCK u(scenesys)=firstof(u(w`query,get`scene`info`specific,scene_lock,%0),type^player|type^object)
&FUN`GET`SCENE`PLAYERPARTICIPATED u(scenesys)=u(w`query,get`scenes`from`filter`scene_state,firstof(%1,3[@@(Finished)] 2[@@(Unfinished)] 1[@@(Paused)] 0[@@(Active)]),u(w`query,get`scenes`from`player_id,%0))
&FUN`GET`SCENE`RECENTATLOC u(scenesys)=u(w`query,get`scene`recentatlocation,%0,u(FUN`sql`timeformat,sub(secs(),v(data`recentscenesecs))),u(FUN`sql`timeformat),if(%1,,LIMIT 1))
&FUN`GET`SCENE`SCENE_WITH_STATE u(scenesys)=u(w`query,get`scenes`from`filter`scene_state,firstof(%1,3[@@(Finished)] 2[@@(Unfinished)] 1[@@(Paused)] 0[@@(Active)],%0)
&FUN`GET`SCENE`STATUS u(scenesys)=switch(u(w`query,get`config`tableinscene,scene_state,%0),3,Finished,2,Unfinished,1,Paused,0,Active,#-1 INVALID SCENE STATE!)
&FUN`GET`SCHEDULEADDARG u(scenesys)=switch(words(trimpenn(regediti(%0,get(%=`reg),setr(entry,$1 $2 [if(lt(convtime($1 $2),secs()),inc(last(time())),last(time()))]|$3|$4|)),|,r),|),3,trim(%q<entry>,|,r),#-1 INVALID STRING)
&FUN`GET`SCHEDULEADDARG`REG u(scenesys)=(.+)/(.+)\s+((?:[01]?[0-9]|2[0-3]):[0-6][0-9])\s+([a-zA-Z0-9!._ ?':-]+)
&FUN`GET`SCHEDULETIMEDAYS u(scenesys)=u(w`query,get`time`diff,u(FUN`sql`timeformat,convtime(first(%0,|))),u(FUN`sql`timeformat,convtime(rest(%0,|))))
&FUN`GET`SCHEDULETIMELINE u(scenesys)=convsecs(convtime(first(%0,-)))[if(rest(%0,-),|[convsecs(convtime(rest(%0,-)))])]
&FUN`GET`SMARTSECONDS u(scenesys)=if(isnum(%0),bound(%0,firstof(%1,v(data`minsmartsecs)),firstof(%2,v(data`maxsmartsecs))),reswitch([stringsecs(squish(regeditall(%0,and,,(\\d+)\\s?(hours?|hrs?|min(?\:ute)?s?|sec(?\:ond)?s?|days?),$1[left($2,1)])))],\\d+,#$,#-1)
&FUN`GET`STATE u(scenesys)=u(w`query,get`config`tableinscene,scene_state,%0)
&FUN`GET`STATE`TONUM u(scenesys)=iter(%0,switch(%i0,finished,3,unfinished,2,paused,1,active,0,all,%%,%i0))
&FUN`GET`STATE`TOWORD u(scenesys)=switch(%0,3,finished,2,unfinished,1,paused,0,active,%0)
&FUN`GET`TABLE u(scenesys)=if( match(config players poser poses tags,%0) , default(me/data`sql`table`%0,scene_[lcstr(%0)]) , #-1 INVALID TABLE )
&FUN`GET`TABLE`LIST u(scenesys)=iter(lattr(me/data`sql`table`),last(%i0,`))
&FUN`GET`TABLENAME u(scenesys)=udefault(me/data`sql`table`%0,#-1 INVALID TABLE)
&FUN`HAS u(scenesys)=
&FUN`HAS`SCHEDULEDSCENE u(scenesys)=u(w`query,get`schedule`ids`ondaybyplayer,u(me/fn`sql`timeformat,convtime(first(%0,|))),u(FUN`get`playerid,%1))
&FUN`IS u(scenesys)=Holds the SceneSys functions that deals with true/false determinations or rights etc.
&FUN`IS`ABLETOJOIN u(scenesys)=and(u(FUN`is`scene`id,%0),match(0 1,u(w`query,get`scene`info`specific,scene_state,%0)),u(FUN`lock`testlock,u(FUN`get`scene`lock,%0),%1))
&FUN`IS`ABLETOTELEPORT u(scenesys)=or(and(elock(%0/teleport,%1),or(hasflag(%0,tel_ok),orflags(%1,Wr))),v(data`alwaystel))
&FUN`IS`EXITSIMILAR u(scenesys)=match(iter(iter(lexits(%1),u(FUN`exitpair,%i0)),u(FUN`get`name,%0) [udefault(%i0/odrop,arrives from [u(FUN`get`name,loc(%i0))])],,|),%2,|)
&FUN`IS`HELPTOPIC u(scenesys)=match(u(FUN`get`help`validoptions),msg`help`[edit(%0,%b,_)])
&FUN`IS`IC u(scenesys)=switch([isic(%0)],#-1*,pemit(%#,Please tell your staffer to install an ISIC function and point them at %!/fn`is`ic),#$)
&FUN`IS`IDLE u(scenesys)=and([gt(sub(secs(),convtime(u(FUN`get`lastposetime`player,%0,%1))),v(data`max`idletodeactivate))],[gt(if(#[idle(%2)],idle(%2),[sub(secs(),convtime(get(%2/lastlogout)))]),v(data`max`idletodeactivate))])
&FUN`IS`INSCENE u(scenesys)=t(match(u(w`query,get`playerid`from`posers,%1),%0))
&FUN`IS`OOCCHATTER u(scenesys)=regmatchi(left(%0,5),\\bOOC\\b)
&FUN`IS`PLAYERID u(scenesys)=u(w`query,get`playerid`from`playerid,%0)
&FUN`IS`POSE_ID u(scenesys)=u(w`query,get`pose`id`poseid,%0)
&FUN`IS`RIGHTVERSION u(scenesys)=t(#[comp(extract(version(),3,3),v(data`minimumversion))])
&FUN`IS`SCENE u(scenesys)=
&FUN`IS`SCENE`ID u(scenesys)=u(w`query,get`scenes`from`sceneid,%0)
&FUN`IS`SCENE`ORDERED u(scenesys)=u(w`query,get`config`tableinscene,scene_ordered,%0)
&FUN`IS`SCENEOWNER u(scenesys)=match(u(w`query,get`scene`owner,%0),u(FUN`get`playerid,%1))
&FUN`IS`SETUP u(scenesys)=firstof(regmatch(%u,v(fn`is`setup`regexp)),t(u(FUN`get`playerid,%:)),0)
&FUN`IS`SETUP`REGEXP u(scenesys)=^[@+-=!.~]?scene(?:/|\s+#)((de|re)?setup|help)(?:\s+(.+))?$
&FUN`IS`SPAM u(scenesys)=or(gt(u(w`query,GET`TIME`BETWEEN,POSES,scene_id,%0,poser_id,%2,pose_time,u(FUN`sql`timeformat,sub(secs(),10)),u(FUN`sql`timeformat,secs())),u(w`query,get`scene`spamtimer,%0)),u(w`query,get`playerid`spammer,%2))
&FUN`IS`STAFF u(scenesys)=switch([isstaff(%0)],#-1 FUNCTION *,orflags(%0,Wr),stext(0))
&FUN`IS`TABLE u(scenesys)=u(w`query,get`table,%0,%1)
&FUN`IS`TOANNOUNCETO u(scenesys)=match(u(w`query,get`player`warnings,%0),%1,\,)
&FUN`IS`VALID u(scenesys)=
&FUN`IS`VALID`SCHEDULEARG u(scenesys)=lmath(and,switch(u(FUN`get`scheduleaddarg,%0),* * *|*|*,#[convtime(squish($0 $1 $3:00 $2))],#-1 INVALID SCHEDULING STRING))
&FUN`IS`VALID`SCHEDULEID u(scenesys)=strlen(u(w`query,get`schedule`ids`byids,%0))
&FUN`IS`VALID`SCHEDULETIMELINE u(scenesys)=and(lmath(and,u(FUN`get`scheduletimeline,%0),|),#[lmath(sub,revwords(iter(u(FUN`get`scheduletimeline,%0),convtime(%i0),|)))])
&FUN`IS`VALIDCREATIONLINE u(scenesys)=localize(not(strlen(regeditall(%0,v(fn`is`validcreationline`regexp),))))
&FUN`IS`VALIDCREATIONLINE`REGEXP u(scenesys)=(?P<FIELD>\w+)=\s*("(?P<VALUEQ>[^"]+)"|(?P<VALUE>[^ ]+?))(\s|$)
&FUN`ISLOGGED u(scenesys)=if(and(not(u(FUN`is`exitsimilar,%0,loc(%1))),not(u(FUN`is`oocchatter,%2)),setr(PlayerID,u(FUN`get`playerid,%1)),gte(words(%2),u(data`minposewords)),not(u(FUN`is`exitsimilar,%0,loc(%1))),setr(SceneID,u(FUN`get`activescene,%q<PlayerID>)),not(u(FUN`is`spam,%q<SceneID>,%1,%q<PlayerID>))),\[[ansi(hg,LOG: %q<SceneID>)]\]%b)[if(setr(LocalScene,u(FUN`get`scene`recentatloc,objid(loc(%1)),1)),[switch(%q<LocalScene>,u(FUN`get`activescene,u(FUN`get`playerid,%1)),,%b[ansi(hw,\[[ansi(hr,X)]\])]%b)])]
&FUN`ISQUISH u(scenesys)=trim(fold(me/fn`isquish`logic,unique(sort(%0,n))))
&FUN`ISQUISH`LOGIC u(scenesys)=if(eq(%1,inc(last(last(%0),-))),strcat(extract(%0,1,dec(words(%0))),%b,first(last(%0),-),-,%1),%0 %1)
&FUN`LOCATE u(scenesys)=locate(%#,%0,*y)
&FUN`LOCK u(scenesys)=Holds the SceneSys functions that deal with locking users. This uses the testlock() function that was created during development of PennMUSH 1.8.3p11: Which is why this system requires an updated version of PennMUSH.                                                                                                                                                To make compatibility easier - if your ServerBase has something similar to testlock(<lock text>,<victim>), or if you'd rather make a different LOCK syntax - you can alter: &FUN`lock`testlock to make use of it.                                                                                              It asumes certain 'replies' from this function to allow a lock to be set. So if you wish to make your own syntax, note that it requires to do the following: In case of 'invalid locktext' --> '#-1 INVALID BOOLEXP', In case of 'victim does not pass' --> 0, In case of 'victim passes' --> 1.
&FUN`LOCK`TESTLOCK u(scenesys)=testlock(%0,%1)
&FUN`MSG u(scenesys)=u(data`msgprefix) [udefault(msg`[edit(%0,%b,`)],%0,%1,%2,%3,%4,%5,%6,%7,%8,%9)]
&FUN`NUMLIST u(scenesys)=sort(setdiff(unique(sort(iter(%0,lnum(max(first(%i0,-),last(%i0,-)),min(first(%i0,-),last(%i0,-)))))),if(%1,numlist(%1))),n)
&FUN`SET u(scenesys)=Used to set basic information.
&FUN`SET`ACTIVESCENE u(scenesys)=u(w`update,set`activescene,switch(%0,,NULL,NULL,NULL,"%0"),%1)
&FUN`SET`CONFIG u(scenesys)=setq(Table,setdiff(%1,scene_id scene_players [@@(scene_state)] scene_owner))[reswitch(strlen(%0)%3,0\[23\],u(w`update,config`defaultset,%q<Table>,%2),1\[1-9\]*,u(w`update,config`sceneset,%q<Table>,%2,firstof(%0,u(FUN`get`activescene,%4))),#-1 INVALID BITLEVEL)][@@(We're using w`update to check if it worked or not!)]
&FUN`SET`POSE u(scenesys)=u(w`update,pose`add,%0,objid(%1),u(FUN`get`name,%1),u(FUN`sql`timeformat),objid(loc(%1)),u(FUN`get`name,loc(%1)))
&FUN`SET`POSE`ORDERMOVE u(scenesys)=iter(0 1 2 3 4 5,u(w`update,pose`moveorderid`%i0,%0,%1,%2,%3)%r[u(w`prepare,pose`moveorderid`%i0,%0,%1,%2,%3)]%r,,%r)
&FUN`SET`POSE`PLAIN u(scenesys)=u(w`update,pose`updateplain,%0,%1)
&FUN`SET`POSE`PLAINADD u(scenesys)=u(w`update,pose`updateplainadd,%0,%1)
&FUN`SET`POSERS u(scenesys)=Sets info for the 'posers' table.
&FUN`SET`POSERS`JOIN u(scenesys)=u(w`update,poser`add,%0,%1)[@@(%0: Scene ID\, %1: Player ID)]
&FUN`SET`POSERS`REMOVE u(scenesys)=u(w`update,poser`rem,%0,%1)[@@({%0: Scene ID, %1: Player ID})]
&FUN`SQL u(scenesys)=Used for special SQL functions, like the 'timeformat'.
&FUN`SQL`TIMEFORMAT u(scenesys)=timefmt($Y-$m-$d  $H:$M:$S,firstof(%0,secs()))
&FUN`TEL u(scenesys)=if(%0,u(FUN`display`cmdtag,[default(me/data`telcommand,@tel)] [first(%0,~)],[default(me/data`telcommand,@tel)] [first(%0,~)]),)
&INCLUDE u(scenesys)=This system uses @include a lot to enhance the effects of this system. All of these includes must be called as an @trig from an OUTSIDE source!
@set u(scenesys)/INCLUDE=no_command
&INCLUDE`ACTIVATE u(scenesys)=@@ Activates a scene for a player.                                                                                                  Arguments= %0: Scene ID, %1: PlayerObjid, %2: PlayerID, %3: Report To                                                                                     ; @assert u(FUN`is`inscene,%2,%0)=                                              @pemit %3=u(FUN`msg,activate`joinfirst)                                     ; th u(FUN`set`activescene,%0,%2)                                             ; @dol u(FUN`get`playerobjid,u(FUN`get`playerid`allinscene,%0))=                 @pemit %iL=u(FUN`msg,activate`done,%il,%2,%1,%0)
&INCLUDE`CONFIGSET u(scenesys)=@@ This gets triggered to set arguments. We'll mainly be making use of fn`set`config in this.                                                                                                               Arguments= SceneID: %0 - ReportTo: %1 - Setting: %2 - Value: %3                                                                                           ; @assert if(strlen(%1),or(u(FUN`is`sceneowner,%0,%1),                                                u(FUN`is`staff,%1)),1)=                                 @pemit %1=u(FUN`msg,notsceneowner)                                                                                                                       ; @assert isnum(setr(ConfigID,u(FUN`set`config,%0,%2,%3,                                setr(Bitlevel,u(FUN`get`bitlevel,%0,%1)),%0)))=                       @pemit %1=u(FUN`msg,configwentwrong,%0,%2,%3,%q<ConfigID>,%q<Bitlevel>)     ; @pemit %1=u(FUN`msg,configset,%0,%2,%3,                                                 firstof(%0,u(FUN`get`activescene,%1)),%q<Bitlevel>)
&INCLUDE`CONNECT u(scenesys)=
&INCLUDE`CONNECT`MISSED_POSE u(scenesys)=@@ We will check based on the person's LASTLOGOUT, if they missed a pose, and then @pemit him how many in each scene, and the +scene/recall format for it. ; th %N missed the following poses: [setr(PoseIDs, [u(w`query,get`pose`from_till_now,u(FUN`sql`timeformat,convtime(get(%#/lastlogout))), setr(SceneID,u(FUN`get`activescene,u(FUN`get`playerid,%:))) )] )] ; @assert %q<PoseIDs>; @wait 3=@inc %vm={Our records indicate you missed some poses. Use +scene/recall [words(%q<PoseIDs>)]=%q<SceneID>}
&INCLUDE`CREATE u(scenesys)=@@ This is the include that gets run to create a scene. It will use a simple regexp to generate scene information, or report errors if the syntax was not valid. It will then use the creation subattributes, matched with the fields given (excluding the string 'scene_'), to sequencially set up a scene.                                                                                                                              Arguments= %0: CreationLine, %1: PlayerObjid                                                                                                              ; @assert u(FUN`is`validcreationline,%0)=                                       @pemit %1=u(FUN`msg,creationline_bad,u(FUN`filter`creationlineerrors,%0))                                                                                 ; @break setr(UselessLine,u(FUN`get`creationline`useless,                              setr(CreationLine,u(FUN`get`creationline,%0))))=                       @pemit %1=u(FUN`msg,creationline_useless,%q<UselessLine>)                                                                                                ; @@ We create the scene ahead of time. It will set %q<SceneID>.             ; @include me/include`create`make=%1                                                                                                                      ; @@ Now that we have a scene in %q<SceneID>, we run all the 'last keys' of the entered creation string as seperate edits to the scene.                                                                                               ; @dol/d [chr(160)] [u(me/fn`filter`creationlinedoubles,%q<CreationLine>)] =   @include me/include`create`[first(%il,|)] =  rest(%il,|) , %q<SceneID> ,                                                  %1 , u(FUN`get`playerid,%1) ; @remit loc(%1)=u(FUN`msg,%N has started a new scene (%q<SceneID>) here\, use +scene/join to join the moment they've posed - or use [u(FUN`display`cmdtag,+scene/join %q<SceneID>)].)
&INCLUDE`CREATE`ANNOUNCE u(scenesys)=@@ Announces, or doesn't announce, a scene upon creation.                                                                                                                                                 Argument= %0: Value, %1: SceneID, %2: PlayerObjid, %3: PlayerID                                                                                           ; @assert and(%0,not(match(no off,%0)))                                      ; @wait 1=                                                                     {  @include me/include`configset=%1,%2,scene_announce,%0                      ; @dol u(FUN`get`playerid`announceto)=                                          @pemit setr(PlayerRef,u(FUN`get`playerobjid,##))=                                   u(me/fn`msg,announcecreate,%0,%1,%2,%3,%q<PlayerRef>) }
&INCLUDE`CREATE`DESC u(scenesys)=@@ Sets the description of the scene to a certain value upon creation.                                                                                                                                  Argument= %0: Value, %1: SceneID, %2: PlayerObjid, %3: PlayerID                                                                                           ; @include me/include`configset=%1,%2,scene_desc,%0
&INCLUDE`CREATE`LOCK u(scenesys)=@@ Sets a lock to ward people from the scene.                                                                                    Argument= %0: Value, %1: SceneID, %2: PlayerObjid, %3: PlayerID                                                                                           ; @pemit %2=u(FUN`msg,lockset,%0,%2,%1)                                       ; @include me/include`config=                                                           %1,%2,scene_lock,switch(u(FUN`lock`testlock,%0,%2),#-1*,#TRUE,%0)
&INCLUDE`CREATE`MAKE u(scenesys)=@@ We create a basic 'scene'. And we then keep the value for its sceneID in %q<SceneID>                                                                                                                      Arguments> %0: PlayerObjid                                                                                                                                ; th u(w`query,set`basicscene,%0,u(FUN`get`playerid,%0),u(FUN`sql`timeformat))      [setq(SceneID,u(w`query,get`scene`latest))]                                                                                                          ; @@ We tell the creator the succeeded.                                      ; @pemit %0=u(FUN`msg,scene`create,%q<SceneID>)                               ; @@ And add them to their own scene.                                        ; @include me/include`scene`addplayer=%q<SceneID>,%0,1,%0
&INCLUDE`CREATE`ORDERED u(scenesys)=@@ Sets a scene to police the pose-order.                                                                                     Argument= %0: Value, %1: SceneID, %2: PlayerObjid, %3: PlayerID                                                                                           ; @include me/include`config=                                                           %1,%2,scene_ordered,reswitch(%0,off|no,0,t(%0))
&INCLUDE`CREATE`PRIVATE u(scenesys)=@@ Sets a scene to private, only allowing the players who were in it - and staff - to read the log.                                                                                                     Argument= %0: Value, %1: SceneID, %2: PlayerObjid, %3: PlayerID                                                                                           ; @include me/include`config=                                                           %1,%2,scene_private,reswitch(%0,off|no,0,t(%0))
&INCLUDE`CREATE`SPAM_TIMER u(scenesys)=@@ Sets a scene's alloted poses per 10 seconds - per player. Should be at least 2 - realistic-wise and to prevent double-poses from getting marked - and max of 7 to make sure nobody abuses this setting..                                                                                                                                            Argument= %0: Value, %1: SceneID, %2: PlayerObjid, %3: PlayerID                                                                                           ; @include me/include`config=                                                           %1,%2,spam_timer,bound(if(isnum(%0),%0,2),2,7)
&INCLUDE`CREATE`TIMEOUT_PAUSE u(scenesys)=@@ Sets a scene's alotted time before its  status is set to 'pause'.                                                                                                                                 Argument= %0: Value, %1: SceneID, %2: PlayerObjid, %3: PlayerID                                                                                           ; @assert setr(Seconds,fn`get`smartseconds,%0)=                                @pemit %#=u(FUN`msg,invalidtimestring)                                                                                                                   ; @include me/include`config=%1,%2,timeout_skip,%q<Seconds>
&INCLUDE`CREATE`TIMEOUT_SKIP u(scenesys)=@@ Sets a scene's alotted time before one is 'skipped' on the game. Basically, it means one is 'away' - but 'skip' is more generalized.                                                                                                                                         Argument= %0: Value, %1: SceneID, %2: PlayerObjid, %3: PlayerID                                                                                           ; @assert setr(T,fn`get`smartseconds,%0)=                                      @pemit %#=u(FUN`msg,invalidtimestring)                                                                                                                   ; @include me/include`config=                                                           %1,%2,timeout_skip,u(FUN`get`smartseconds,%0)
&INCLUDE`CREATE`TIMEOUT_UNFINISHED u(scenesys)=@@ Sets a scene's alotted time before its  status is set to 'unfinished'.                                                                                                                       Argument= %0: Value, %1: SceneID, %2: PlayerObjid, %3: PlayerID                                                                                           ; @assert setr(Seconds,fn`get`smartseconds,%0)=                                @pemit %#=u(FUN`msg,invalidtimestring)                                                                                                                   ; @include me/include`config=%1,%2,timeout_skip,%q<Seconds>
&INCLUDE`CREATE`TITLE u(scenesys)=@@ Sets the title of the scene to a certain value upon creation. If you want, you could filter the value here for swears etc.                                                                               Argument= %0: Value, %1: SceneID, %2: PlayerObjid, %3: PlayerID                                                                                           ; @include me/include`configset=%1,%2,scene_title,%0
&INCLUDE`DEACTIVATE u(scenesys)=@@ De-activates the scene you are currently in. A staffer can force this on a player. Does not leave a scene!                                                                                               Arguments= %0: PlayerID, %1: ReportTo, %2: Executor, %3: Optional Comment                                                                                 ; th u(FUN`set`activescene,NULL,%0)                                           ; @pemit %1=u(FUN`msg,deactivate,%1,%2,%3)                                    ; @break match(%1,%2)                                                        ; @pemit %2=u(FUN`msg,deactivate`done,%1,%2,%3)
&INCLUDE`JOIN u(scenesys)=@@ Triggers when someone is added to a scene.
&INCLUDE`KICK u(scenesys)=@@ This is an event include. It runs when someone has already been kicked from a scene.                                                                                                                         Arguments = %0: Kicked Player DBref, %1: SceneID, %2: Executor objid                                                                                      ; @pemit/list filter(fn`is`staff,lwho())=u(FUN`msg,kick`event,%2,%0,%1)
&INCLUDE`LASTPOSE u(scenesys)=
&INCLUDE`LASTPOSE`CATCHPOSE u(scenesys)=@assert u(FUN`is`ic,%1);@trig me/include`pose=[u(FUN`get`name,%1)] , %1 , %0 , [u(FUN`sql`timeformat)]
&INCLUDE`LASTPOSE`POSTPOSE u(scenesys)=@assert u(FUN`is`ic,%1) ; @dol/inline [lockfilter(lastpose`post:1,lvplayers(%L))]=@pemit ##=%r[u(FUN`display`footer,<%b[u(FUN`islogged,name(%1),%1,%0)]End of [ansi(hw,accname(%1))]'s pose%b>,,##)] ; &lastpose %#=%qR ; &lastpose`secs %#=[secs()] ; &observe %1=0
&INCLUDE`LASTPOSE`PREPOSE u(scenesys)=@assert u(FUN`is`ic,%1) ; @dol/inline [lockfilter(lastpose`pre:1,lvplayers(%L))]=@nspemit ##=u(FUN`display`header,<%b[u(FUN`islogged,name(%1),%1,%0)][ansi(+white,accname(%1))] has posed%b>,,##)%r
&INCLUDE`LEAVE u(scenesys)=@@ Run when a person leaves a scene of their own volition.                                                                                                                                                 Arguments = %0: Scene ID, %1: Target Objid                                                                                                               ; @include me/include`scene`remplayer=%0,%1,%2                               ; @include me/include`deactivate=u(FUN`get`playerid,%1),%1,%1
&INCLUDE`LOOP u(scenesys)=@@ This is the main loop that continues to be run by this system, it will @trig itself at the end to keep this loop going. Make sure this room is powered as NO_PAY, or it will run out of money real fast like.                                                                              ; @@ First, we find all the TASKS to run, and trigger those!                 ; @dolist lattr(me/include`loop`**)=@trig me/%iL                                                                                                          ; @@ And here is the main process loop trigger.                              ; @wait 20=@trig me/include`loop
@set u(scenesys)/INCLUDE`LOOP=no_debug
&INCLUDE`LOOP`PLAYER u(scenesys)=@@ Checks based on player-status.
&INCLUDE`LOOP`PLAYER`TIMEOUT u(scenesys)=@@ Based on a player-timeout.
&INCLUDE`LOOP`PLAYER`TIMEOUT`IDLE u(scenesys)=@@ Check if a player has timed out in any scenes, and should be set idle.                                                                                                                       ; @dol u(w`query,get`playerid`hasactivescene)=                                 {                                                                                th [setq(SceneID,u(FUN`get`activescene,%iL))]                               ; th [setq(PlayerObjid,u(FUN`get`playerobjid,%iL))]                           ; @switch u(FUN`is`idle,%iL,%q<SceneID>,%q<PlayerObjid>) =                      1,                                                                             { @include me/include`deactivate=%iL,%q<PlayerObjid>,%!,Idle }         }
&INCLUDE`LOOP`PLAYER`TIMEOUT`SKIP u(scenesys)=@@ Check if a player has timed out in any scenes, and should be set skip.
&INCLUDE`LOOP`SCENE u(scenesys)=@@ Checks based on system-status.
&INCLUDE`LOOP`SCENE`TIMEOUT u(scenesys)=@@ Based on a player-timeout.
&INCLUDE`LOOP`SCENE`TIMEOUT`PAUSE u(scenesys)=@@ Check for scene-activity. Are there any scenes that should be set as 'paused'? ; @dol u(w`query,get`scene`forpause_auto)=@inc me/include`configset=##,u(FUN`get`playerobjid,u(w`query,get`scene`ownerid,##)),scene_state,1
&INCLUDE`LOOP`SCENE`TIMEOUT`UNFINISHED u(scenesys)=@@ Check for scene-activity. Are there any scenes that should be set as 'paused'? ; @dol u(w`query,get`scene`forunfinished_auto)={ @inc me/include`configset=##,setr(PlayerObjid,[if(isobjid(setr(OwnerObjid,u(FUN`get`playerobjid, u(w`query,get`scene`ownerid,##))) ),%q<OwnerObjid>,u(FUN`get`playerobjid,1))]),scene_state,2 ; @pemit %q<PlayerObjid>=u(FUN`msg,setunfinished,##,%q<OwnerObjid>,%q<PlayerObjid>); }
&INCLUDE`OVERRIDE u(scenesys)=@dol @emit pose say semipose=@hook/override ##=me,override`##
&INCLUDE`PLAYER u(scenesys)=Player based triggers. Such as the setup.
&INCLUDE`PLAYER`DESETUP u(scenesys)=@@ This disables a player on the SceneSys playerid list!                                                                                                                                            Arguments= ReportTo: %0 - ObjId: %1                                                                                                                       ; @assert %1=                                                                  @pemit owner(%!)=u(FUN`msg,TRIG`PLAYER`DESETUP: %%1 returned nothing.)[@@(%1 is nothing? Then we do nothing!)]                                                                                                         ; @assert u(FUN`is`playerid,%1)=                                                @pemit %0=u(FUN`msg,playerid`not)[@@(Should be self explainatory.)]         ; th u(w`query,player`desetup,%1)[@@(And we remove them!)]                   ; @pemit %0=u(FUN`msg,setup`removed,%1)
&INCLUDE`PLAYER`RESETUP u(scenesys)=@@ This disables a player on the SceneSys playerid list!                                                                                                                                            Arguments= ReportTo: %0 - ObjId: %1                                                                                                                       ; @assert %1=                                                                  @pemit owner(%!)=u(FUN`msg,TRIG`PLAYER`RESETUP: %%1 returned nothing.)[@@(%1 is nothing? Then we do nothing!)]                                                                                                         ; @assert u(FUN`is`playerid,%1)=                                                @pemit %0=u(FUN`msg,playerid`not)[@@(Should be self explainatory.)]                                                                                      ; th u(w`query,player`resetup,%1)[@@(And we remove them!)]                   ; @pemit %0=u(FUN`msg,setup`resetup,%1)
&INCLUDE`PLAYER`SETUP u(scenesys)=@@ This sets up a player for using the SceneSys!                                                                           Arguments= ReportTo: %0 - ObjId: %1                                                                                                                       ; @assert %1=                                                                  @pemit owner(%!)=u(FUN`msg,TRIG`PLAYER`SETUP: %%1 returned nothing.)[@@(%0 is nothing? Then we do nothing!)]                                                                                                                        ; @break u(FUN`get`playerid,%1)=                                                @pemit %0=u(FUN`msg,setup`alreadydone,%1)[@@(They are already setup. Silly people!)]                                                                                                                                                 ; th u(w`query,player`setup,%1,u(FUN`get`name,%1),u(FUN`get`bitlevel,%1))[@@(And we set them up!)]                                                               ; @pemit %0=u(FUN`msg,setup`complete,%1)
&INCLUDE`POSE u(scenesys)=@@ This is what gets triggered when a room detects something being said. Here we filter things and run around main system. This is important!                                                                                                                                             Arguments= %0: Playername - %1: ObjectID - %2: ANSI Pose.                                                                                                 ; @assert match(v(data`listento),type(%1))[@@(We only listen to certain types of object types!)]                                                                                                                                  ; @break u(FUN`is`oocchatter,%2)[@@(We won't listen to OOC chatter!)]                                                                                     ; @assert setr(PlayerID,u(FUN`get`playerid,%1))                                        [@@(We don't listen to anyone who is not set up for this system!)]                                                                               ; @assert gte(words(%2),v(data`minposewords))[@@(We asume a pose should have a minimum length. This is to drown out movement messages and people spamming the SceneSys.)]                                                                                                                                          ; @break u(FUN`is`exitsimilar,%0,loc(%1))[@@(Ugly check for whether or not something was exit talk.)]                                                                                                                                ; @assert setr(SceneID,u(FUN`get`activescene,%q<PlayerID>))                     [@@(If we cannot find an active scene for them\, we'll let include`pose`noactivescene figure out what to do next)]=                       @include me/include`pose`noactivescene = %0,%1,%2,%4                                                                                                    ; @break u(FUN`is`spam,%q<SceneID>,%1,%q<PlayerID>)=                            @include me/include`spam=%q<SceneID>,%1                                                                                                                 ; @include me/include`pose`announce = %1,%q<SceneID>,%l,%2                   ; @include me/include`pose`[if(u(FUN`get`scene`ordered,%q<SceneID>)                                      ,order,add)] = %1,%q<SceneID>,%1,%2
&INCLUDE`POSE`ADD u(scenesys)=@@ This will add a pose to the database. It will require the 'active scene' to have been figured out ahead of time.                                                                                        Arguments= %0: ReportTo, %1: SceneID, %2: Poser, %3: Pose                                                                                                ; @assert lt(strlen(edit(%3,%t,space(4))),mul(setr(BufferMax,sub(u(data`maxbuffer),10)),2))=     @pemit %0=u(FUN`msg,The pose was too big to record. Please chop it down to [mul(%q<BufferMax>,2)] characters.)                                                                                                                      ; @@ We split up this code, so we can hold the most information in the attribute, and get around the annoying COMMAND_LEN buffer problem.                                                                                        ; th setq(PoseReport,u(FUN`set`pose,%1,%2))                                   ; th u(FUN`set`pose`plain,mid(edit(%3,%t,space(4)),0,%q<BufferMax>),%q<PoseReport>)            ; th u(FUN`set`pose`plainadd,                                                      mid(edit(%3,%t,space(4)),%q<BufferMax>,mul(%q<BufferMax>,2)),%q<PoseReport>) ; @break match(2 1,u(FUN`get`state,%1))=@inc me/include`configset=%1,[if(isdbref(setr(PlayerObjid,u(FUN`get`playerobjid, u(w`query,get`scene`ownerid,%1))) ),%q<PlayerObjid>,u(FUN`get`playerobjid,1))],scene_state,0
&INCLUDE`POSE`ANNOUNCE u(scenesys)=@@ This is what gets triggered when a pose gets added. We check for the player 'warnings' they want to listen to.                                                                                        Arguments= Poser: %0 - ActiveSceneID: %1 - Location: %2 - ANSI Pose: %3                                                                                   ; @pemit/list [u(FUN`get`objids_notinroom,%1,%0)]=u(FUN`msg,[name(%0)] posed to this scene (%1) in another room.)
&INCLUDE`POSE`CHANGE_ORDER u(scenesys)=@@ This will exchange the order_id of two poses within the scene scene.                                                                                                                          Arguments= %0: ReportTo, %1: SceneID, %2: order_id-1, %3: order_id-2                                                                                      ; @assert and(setr(PoseID1,u(w`query,get`pose`id`scene_and_order,%1,%2)),              isint(%1),isint(%2))=                                                @pemit %0=u(FUN`msg,nosuchorderid,%2)                                      ; @assert and(setr(PoseID2,u(w`query,get`pose`id`scene_and_order,%1,%3)),              isint(%1),isint(%3))=                                                @pemit %0=u(FUN`msg,nosuchorderid,%3)                                      ; th setq(ToNullSuccess,u(w`update,pose`changeorderid,NULL,%q<PoseID1>))     ; th setq(FirstChangeSuccess,u(w`update,pose`changeorderid,%2,%q<PoseID2>))  ; th setq(SecondChangeSuccess,u(w`update,pose`changeorderid,%3,%q<PoseID1>))                                                                              ; @pemit %0=u(FUN`msg,orderidexchange,%1,%2,%3)
&INCLUDE`POSE`IGNORE u(scenesys)=@@ This will (un)set a pose_id as 'ignore', and will thus (no longer) ignore it from showing up in logs and scene recalls. This will not DELETE the pose! This is the prefered method or removing poses, to prevent sabotage.                                                                                                                               Arguments= %0: ReportTo, %1: pose_id, %2: on/off                                                                                                          ; @assert u(FUN`is`pose_id,%1) =                                                @pemit %0=u(FUN`msg,nosuchpose)                                                                                                                          ; @assert setr(Error,u(w`update,set`pose`ignore,t(%2),%1)) =                   @pemit %0=u(FUN`msg,somethingwentwrong,%q<Error>,INCLUDE`POSE`IGNORE)       ; @pemit %0=u(FUN`msg,ignoreset,%2,%1)
&INCLUDE`POSE`MOVE_ORDER u(scenesys)=@@ This will move the order_id of one pose behind another.                                                                                                                                  Arguments= %0: ReportTo, %1: SceneID, %2: order_id-1, %3: order_id-2                                                                                      ; @assert and(u(w`query,get`pose`id`scene_and_order,%1,%2),                            isint(%1),isint(%2))=                                                @pemit %0=u(FUN`msg,nosuchorderid,%2)                                       ; @assert and(u(w`query,get`pose`id`scene_and_order,%1,%3,replace),                    isint(%1),isint(%3))=                                                @pemit %0=u(FUN`msg,nosuchorderid,%3)                                      ; th setq(MaxID,inc(u(w`query,get`pose`order_id`max,%1)))                    ; th u(me/fn`set`pose`ordermove,%2,%3,%q<MaxID>,%1)
&INCLUDE`POSE`NOACTIVESCENE u(scenesys)=@@ This is what gets triggered if there was no active scene detected for the player.                                                                                                                 Arguments = %1:
&INCLUDE`RECALL u(scenesys)=@@ This is the scene recall include. It recalls poses from the scene as defined.                                                                                                                                Arguments= %0: Recall Min, %1: Recall Max, %2: Scene ID                                                                                                   ;  @mapsql me/include`recall`line=setq(PlayerDBref,%#)[setr(Prepare,u(FUN`get`recallids`prepare,%2,%0,%1))][setq(RecallIDs,words(sql(%q<Prepare>)))]
&INCLUDE`RECALL`LINE u(scenesys)=@nspemit %q<PlayerDBref>=u(FUN`display`recallpose,r(POSE_ID,args),%0,%q<RecallIDs>)
&INCLUDE`SCENE u(scenesys)=Holds the removal and addition of players.
&INCLUDE`SCENE`ADDPLAYER u(scenesys)=@@ This runs to add a player to a scene. It assumes things like locks have been checked ahead of time, so that it can add people like staff to a scene as well, as well as letting scene-owners and staffers 'add' a player to a scene, circumventing 'private' locks or locks in general. This can still not add a player to a FINISHED or UNFINISHED scene! If it finds a duplicate, it will warn!                                                                                           Arguments= %0: Scene ID, %1: Player Objid, %2: AutoJoin?, %3: Report To                                                                                   ; @assert u(FUN`is`scene`id,%0)=                                                @pemit %3=u(FUN`msg,nosuchscene,%0)                                                                                                                      ; @assert match(0 1,u(w`query,get`scene`info`specific,scene_state,%0))=        @pemit %3=u(FUN`msg,cannotjoinscene`state,%0)                                                                                                            ; @switch u(FUN`set`posers`join,%0,u(FUN`get`playerid,%1))=                      #-1 * DUPLICATE *                                                            , @pe/li unique(objid(%3) %1)=u(FUN`msg,alreadyinscene,%1,objid(%3),%0)       , @pe/li unique(objid(%3) %1)=u(FUN`msg,scene`join,%1,objid(%3),%0)                                                                                     ; @assert %2[@@(Autojoin them to the scene?)]                                ; @include me/include`activate=%0,%1,u(FUN`get`playerid,%1),%3
&INCLUDE`SCENE`REMPLAYER u(scenesys)=@@ This runs to remove a player from a scene. It assumes things like locks have been checked ahead of time, so that it can remove people like staff from a scene as well, as well as letting scene-owners and staffers 'remove' a player from a scene, circumventing 'private' locks or locks in general. This cannot remove a player from a scene they are not in!                                                                                                                                  Arguments= %0: Scene ID, %1: Player Objid, %2: Report To                                                                                                 ; @assert u(FUN`is`scene`id,%0)=                                                @pemit %2=u(FUN`msg,nosuchscene,%0)                                                                                                                      ; @assert u(FUN`is`inscene,u(FUN`get`playerid,%2),%0)=                           @pemit %2=u(FUN`msg,notinscene,%0)                                                                                                                      ; @assert match(0 1,u(w`query,get`scene`info`specific,scene_state,%0))=        @pemit %2=u(FUN`msg,cannotleavescene`state,%0,%1,%2)                                                                                                     ; th u(FUN`set`posers`remove,%0,u(FUN`get`playerid,%1))                       ; @dol unique(objid(%2) %1)=                                                   @pemit %il=u(FUN`msg,scene`leave,%1,objid(%2),%0,%il)
&INCLUDE`SCHEDULE u(scenesys)=
&INCLUDE`SCHEDULE`ADD u(scenesys)=@@ This include adds a scene to the schedule. It assumes that all the testing has been done by the command. We're expecting the ScheduleData to be in the form of 'MMM DD YYYY|HH:MM|TITLE'.                                                                                          Arguments= %0: SendTo, %1: Player ID, %2: ScheduleData, %3: Scene Description, %4: Character Name, %5: room                                                                                                                 ; @assert setr(ScheduleSet,u(w`update,set`schedule                             ,u(me/fn`sql`timeformat,convtime(switch(%2,* * *|*|*,$0 $1 $3:00 $2,#$)))      ,rest(rest(%2,|),|),%1,%4,%3,%5)) =                                                                                                                       @pemit %0=u(FUN`msg,SQL`ERROR,%q<ScheduleSet>)                                                                                                           ; @pemit %0=u(FUN`msg,Schedule`Success,%q<ScheduleSet>,%1,%2)                       ; @cemit/noisy Public=[name(%0)] has scheduled a scene[if(%5,%bin the room '[name(%5)]')] on [first(%2,|)] at [elements(%2,2,|)] [timefmt($Z)], titled: '[u(FUN`display`cmdtag,+scenes %q<ScheduleSet>,last(%2,|))]'. ; @include me/include`schedule`success=%0,%1,%q<ScheduleSet>,first(%2,|),elements(%2,2,|),last(%2,|),%3,%5
&INCLUDE`SCHEDULE`DEL u(scenesys)=@@ This include deletes a scene from the schedule listing.                                                                                                                                                  Arguments= %0: Respond To, %1: Schedule ID                                                                                                                ; @assert setr(QueryResult,u(w`update,set`schedule`delete,%1))=                @pemit %0=u(FUN`msg,SQL`ERROR,%q<QueryResult>)                              ; @pemit %0=u(FUN`msg,schedule`del,%1) ; @inc me/include`schedule`del_success=%1
&INCLUDE`SCHEDULE`DEL_SUCCESS u(scenesys)=@break [setr(Find,u(FUN`get`bbpost,%0))]=+bbremove [v(data`scheduleboard)]/%q<Find>
&INCLUDE`SCHEDULE`RESCHEDULE u(scenesys)=@@ This include reschedules a scene from the schedule listing.                                                                                                                                     Arguments= %0: Respond To, %1: Schedule ID, %2: New Date                                                                                                  ; @assert setr(ScheduleSet,u(w`update,set`schedule`update,                     u(FUN`sql`timeformat,convtime(switch(%2,* * *|*|*,$0 $1 $3:00 $2,#$))),%1)) =    @pemit %0=u(FUN`msg,SQL`ERROR,%q<ScheduleSet>)                              ; @pemit %0=u(FUN`msg,schedule`reschedule,%0,%1,%2)
&INCLUDE`SCHEDULE`SUCCESS u(scenesys)=+bbpost [v(data`scheduleboard)]/Schedule #%q<ScheduleSet>: %5=[ansi(hw,Title)]: %5%r[ansi(hw,Posted by)]: [name(%0)]%r[ansi(hw,Scheduled Time)]: %3 @ %4[if(%7,%r[ansi(hw,Room)]: [name(%7)] ([u(FUN`tel,%7)]))]%r[u(FUN`display`midline)]%r%6
&INCLUDE`SCHEDULE`VIEW u(scenesys)=@@ This include gets called to display a schedule - we are using @retry instead of a map() or iter() in case of long values.                                                                                Arguments= %0: Respond To, %1: Timeline, %2: Timeline Days                                                                                               ; @pemit %0=u(FUN`display`header,< Current Schedule in [timefmt($Z)] >)                   ; @dol/notify repeat(1%b,inc(%2))=@pemit %0=[u(FUN`display`schedule`day,dec(#@),first(%1,|))]  ; @wait me=@pemit %0=u(FUN`display`footer,< [ansi(hw,+scenes #)] >)
&INCLUDE`SPAM u(scenesys)=@@ When spam has been detected, warn the person, and remove them from the scene.                                                                                                                               Arguments= %0: SceneID, %1: PlayerObjid, %2: PlayerID                                                                                                     ; @pemit %1=u(FUN`msg,warn`spam,%1,%0)                                        ; @include me/include`scene`remplayer=%0,%1,%!
&MSG u(scenesys)=Holds all messages. There create output which should be handled by a command of function. They do not send anything themselves.
@set u(scenesys)/MSG=no_command
&MSG`ACTIVATE u(scenesys)=
&MSG`ACTIVATE`DONE u(scenesys)=switch(%0,%2,Your active scene is now #%3,u(FUN`get`name,%2) activated this scene (%3)).
&MSG`ACTIVATE`JOINFIRST u(scenesys)=You must first join that scene!
&MSG`ALREADYINSCENE u(scenesys)=switch(%0,%1,You are already in scene #%2,u(FUN`get`name,%1) tried adding [u(FUN`get`name,%0)] to scene #%2\, but they were already in that scene).
&MSG`ANNOUNCECREATE u(scenesys)=[u(FUN`get`name,%2)] created scene (#%1) in [u(FUN`get`name,loc(%2))][if(u(FUN`is`abletoteleport,loc(%2),%4),%b[ansi(hg,\([u(FUN`tel,loc(%2))]\))].)]%r[u(FUN`msg,{[speak(&[u(FUN`get`name,%#)],%0,notes\,)]})]
&MSG`BADVERSION u(scenesys)=Warning! You are running a version of PennMUSH that does NOT support SceneSys. Please make sure to upgrade to PennMUSH [v(data`minimumversion)] or above! If you believe you got this message in error, alter the data`minimumversion attribute to your current version.
&MSG`CANNOTADDTOSCENE u(scenesys)=You cannot add %1 to scene #1 because you do not have the permissions to do so.
&MSG`CANNOTJOINSCENE u(scenesys)=switch(s:%0,s:,There are no recent scenes in this room.,s:%1,You cannot join scene %0.,A general error occured. You cannot join this scene.)
&MSG`CANNOTJOINSCENE`STATE u(scenesys)=You cannot join scene %0 because of its scene-state.
&MSG`CANNOTLEAVESCENE u(scenesys)=
&MSG`CANNOTLEAVESCENE`STATE u(scenesys)=You cannot leave that scene, as it is set as 'Finished' or 'Unfinished'. Use +scene/deactivate instead.
&MSG`CANNOTREMFROMSCENE u(scenesys)=You do not have the permission to remove that player from the scene.
&MSG`CANTFIND u(scenesys)=No matter how hard I tried\, I could not find '%0'!
&MSG`CONFIGSET u(scenesys)=reswitch(strlen(%0)%4,0\[23\],Defaults for '%1' set to '%2'.,1\[123\]*,Scene '%0' option '%1' set to '[u(w`query,get`config`anytable,%1,scene_id,%0)]'.,#-1 INVALID BITLEVEL)
&MSG`CONFIGWENTWRONG u(scenesys)=switch(%3,#-1 SQL ERROR: Unknown column*,You tried to alter an invalid option.,#-1 SQL ERROR: Invalid default value for*,You specified invalid value '%2' for '%1'.,#-1 SQL ERROR: Data truncated for column*,You specified invalid value '%2' for '%1'.,Something went wrong! @mail your admin with the following: %3)
&MSG`CREATIONLINE_BAD u(scenesys)=Bad syntax for the scene creation: %0
&MSG`CREATIONLINE_USELESS u(scenesys)=There were leftover creation variables we didn't know what to do with: [itemize(iter(%0,ansi(hw,%i0)))].
&MSG`DEACTIVATE u(scenesys)=switch(%1,%0,You've deactivated your current scene.,switch(%1,%!,SceneSys,name(%1)) has deactivated you from your current scene. [if(strlen(%2),Reason: %2)])
&MSG`DEACTIVATE`DONE u(scenesys)=You have deactivated [name(%0)]'s current scene.
&MSG`DONTOWNSCHEDULE u(scenesys)=You don't own that schedule entry.
&MSG`HELP u(scenesys)=Contains helpfiles, for the users. These get read using the fn`display`help function.
&MSG`HELP`ACTIVATE u(scenesys)=Syntax: %r%t[v(data`gameprefix)]scene/activate%r%t[v(data`gameprefix)]scene/deactivate%r%rWorkings:%r%rActivates or deactivates you from a scene. Making your poses (no longer) be directed to a certain scene!
&MSG`HELP`ADDPLAYER u(scenesys)=[ansi(hw,Syntax:)]%r[space(4)]+scene/addplayer <Scene>=<Player>%r%rAs a scene-owner, allows you to add a person to your scene. Do not abuse this!
&MSG`HELP`COMMON u(scenesys)=Common commands and command aliasses: %r%t* +scene/title <id>=<title>%r%t* +scene/desc <id>=<description>%r%t* +scene/create title="<title>"%r%t* +scene/create announce="Running a scene!"%r%t* +scene/create title="<title>" announce="<announcement>"%r%t* +scene/finish
&MSG`HELP`CONFIG u(scenesys)=Syntax: %r%t[v(data`gameprefix)]scene/config [ansi(hm,<)][ansi(hw,Scene)][ansi(hm,>)]%r%t[v(data`gameprefix)]scene/config [ansi(hm,<)][ansi(hw,Scene)][ansi(hm,>)]/[ansi(hm,<)][ansi(hw,Setting)][ansi(hm,>)]%r%t[v(data`gameprefix)]scene/config [ansi(hm,<)][ansi(hw,Setting)][ansi(hm,>)]=[ansi(hm,<)][ansi(hw,Value)][ansi(hm,>)]%r%t[v(data`gameprefix)]scene/config [ansi(hm,<)][ansi(hw,Scene)][ansi(hm,>)]/[ansi(hm,<)][ansi(hw,Setting)][ansi(hm,>)]=[ansi(hm,<)][ansi(hw,Value)][ansi(hm,>)]%r%rDisplay, or change the setting on one of your scenes, such as the title, or the description. It may be useful to check +scene/config so you know exactly what 'settings' there are to edit.
&MSG`HELP`CREATE u(scenesys)=Syntax: %r%t[v(data`gameprefix)]scene/create option=value option2="another value" (etc)%r%rThis system will create a scene, with you as the scene owner. Valid options are listed below:%r%r[align(20(hc) [sub(width(%#),21)](hc),Option:,Explanation:)]%r[iter(setdiff(u(w`query,get`table,v(data`sql`table`config),%%),scene_id scene_owner scene_ctime scene_etime scene_state scene_players),align(20(h) [sub(width(%#),21)],edit(%i0,scene_,):,u(w`query,get`tablecomment,v(data`sql`table`config),%i0)),,%r)]
&MSG`HELP`CREDIT u(scenesys)=Credit to the SceneSys, and all rights, go to: %r%rMercutio@M*U*S*H / Oathkeeper@FinalKingdomMUSH%rEmail: admin@twilightdays.org.%r%rInfo on SceneSys: %r%thttp://www.tumblr.com/blog/mush-mercutio %r%thttp://www.tumblr.com/tagged/scenesys
&MSG`HELP`FINISH u(scenesys)=Syntax: %r%t[v(data`gameprefix)]scene/finish%r%rWorkings:%r%rWill set the scene as 'finished'. No more poses will be recorded in this scene. If you wish to un-finish it, or set it back to active, change the value using +scene/config (until a better option is implemented).
&MSG`HELP`HELP u(scenesys)=Syntax: %r%t[v(data`gameprefix)]scene/help%r%t[v(data`gameprefix)]scene/help [ansi(hm,<)][ansi(hw,topic)][ansi(hm,>)]%r%rWorkings:%r%rIt's what you are using right now!
&MSG`HELP`INFO u(scenesys)=Syntax: %r%t[v(data`gameprefix)]scene/info ([ansi(hm,<[ansi(hw,Scene ID)]>)])%r%rWorkings:%r%rThis lets you see the basic information about a scene. Without an argument, you simply get to see the one you are active in.
&MSG`HELP`LEAVE u(scenesys)=Syntax: %r%t[v(data`gameprefix)]scene/leave%r%t[v(data`gameprefix)]scene [ansi(hm,<)][ansi(hw,SceneID)][ansi(hm,>)]%r%rLeaves a scene. [ansi(hr,This is not the same as deactivating)] a scene. Deactivating a scene simply stops your poses from being recorded in that scene. Leaving it means you get no more information from that log. (You are considered 'not being in that scene). %r%rThis is the command you want if you accidentally join a scene.
&MSG`HELP`LIST u(scenesys)=Syntax: %r%t[v(data`gameprefix)]scene/list%r%t[v(data`gameprefix)]scene/list [ansi(hm,<)][ansi(hw,Statuses)][ansi(hm,>)]%r%rWorkings:%r%rDisplays all the scenes that match a certain status, or multiple statuses. Valid statuses are: 'finished', 'unfinished','active' and 'paused'. %r%r'[v(data`defaultlist)]' is the default.
&MSG`HELP`MINE u(scenesys)=Syntax: %r%t[v(data`gameprefix)]scene/mine%r%t[v(data`gameprefix)]scene/mine/finished%r%t[v(data`gameprefix)]scene/mine/unfinished%r%rWorkings:%r%rShows your 'mine' screen. Numbering your completed scenes, and giving some basic info on scenes you are currently part of; paused or unfinished. The second command displays the scenes you /finished/ rather than the ones that are active. And /unfinished does the next logical thing.
&MSG`HELP`MOVE u(scenesys)=Syntax:%r%t[v(data`gameprefix)]scene/move [ansi(hm,<)][ansi(hw,Order ID)][ansi(hm,>)]=[ansi(hm,<)][ansi(hw,Order ID)][ansi(hm,>)]%r%t[v(data`gameprefix)]scene/move [ansi(hm,<)][ansi(hw,SceneId)][ansi(hm,>)]/[ansi(hm,<)][ansi(hw,Order ID)][ansi(hm,>)]=[ansi(hm,<)][ansi(hw,Order ID)][ansi(hm,>)]%r%t[v(data`gameprefix)]scene/move [ansi(hm,<)][ansi(hw,Order ID)][ansi(hm,>)]=[ansi(hm,<)][ansi(hw,Up/Down/+/-)][ansi(hm,>)] [ansi(hm,<)][ansi(hw,Count)][ansi(hm,>)]%r%t[v(data`gameprefix)]scene/move [ansi(hm,<)][ansi(hw,SceneId)][ansi(hm,>)]/[ansi(hm,<)][ansi(hw,Order ID)][ansi(hm,>)]=[ansi(hm,<)][ansi(hw,Up/Down/+/-)][ansi(hm,>)] [ansi(hm,<)][ansi(hw,Count)][ansi(hm,>)]%r%t[v(data`gameprefix)]scene/move [ansi(hm,<)][ansi(hw,Order ID)][ansi(hm,>)]=[ansi(hm,<)][ansi(hw,Above/Under)][ansi(hm,>)] [ansi(hm,<)][ansi(hw,Order ID)][ansi(hm,>)]%r%t[v(data`gameprefix)]scene/move [ansi(hm,<)][ansi(hw,SceneId)][ansi(hm,>)]/[ansi(hm,<)][ansi(hw,Order ID)][ansi(hm,>)]=[ansi(hm,<)][ansi(hw,Above/Under)][ansi(hm,>)] [ansi(hm,<)][ansi(hw,Order ID)][ansi(hm,>)]%r%rWorkings:%r%rThese are a lot of commands to do the same thing. Move poses around in a scene.%r%rThe first two commands are to exchange two poses' position.%r%rThe second two commands move a pose up or down by a certain number.%r%rThe last two commands move a pose into a position above or under another - as one would find it in the [v(data`gameprefix)]scene/recall listing.
&MSG`HELP`POSE u(scenesys)=A 'pose' is defined as anything done, while [ansi(hwu,active)] in a scene, the scene itself being [ansi(hwu,active)] as well, and having more than [v(data`minposewords)] 'words' in it.
&MSG`HELP`RECALL u(scenesys)=Syntax:%r%t[v(data`gameprefix)]scene/recall %r%t[v(data`gameprefix)]scene/recall [ansi(hm,<)][ansi(hw,Quantity)][ansi(hm,>)]%r%t[v(data`gameprefix)]scene/recall [ansi(hm,<)][ansi(hw,Quantity)][ansi(hm,>)]=[ansi(hm,<)][ansi(hw,Scene)][ansi(hm,>)]%r%rWorkings:%r%rThe first command shows the last couple of poses in your scene. %r%rThe second version lets you indicate how many poses to display since the last. You can alternatively indicate a number-range like '5-10', to read pose 5-10.%r%rThe third version works much like the first, but also allows for indication of what scene's recall you wish to read.
&MSG`HELP`SCENE u(scenesys)=Syntax: %r%t[v(data`gameprefix)]scene%r%t[v(data`gameprefix)]scene [ansi(hm,<)][ansi(hw,SceneID)][ansi(hm,>)]%r%rWorkings:%r%rThe first option shows the same screen as +scene/mine. The second shows the scene's +scene/info.
&MSG`HELP`SCHEDULE u(scenesys)=Syntax: %r%t+scene/schedule [ansi(hm,<)][ansi(hw,Date Range)][ansi(hm,>)]%r%t+scene/schedule/view [ansi(hm,<)][ansi(hw,Schedule ID)][ansi(hm,>)]%r%t+scene/schedule/add [ansi(hm,<)][ansi(hw,Month)][ansi(hm,>)]/[ansi(hm,<)][ansi(hw,Day)][ansi(hm,>)] [ansi(hm,<)][ansi(hw,Time)][ansi(hm,>)] [ansi(hm,<)][ansi(hw,Title)][ansi(hm,>)]=[ansi(hm,<)][ansi(hw,Description)][ansi(hm,>)]%r%t+scene/schedule/add/here [ansi(hm,<)][ansi(hw,Month)][ansi(hm,>)]/[ansi(hm,<)][ansi(hw,Day)][ansi(hm,>)] [ansi(hm,<)][ansi(hw,Time)][ansi(hm,>)] [ansi(hm,<)][ansi(hw,Title)][ansi(hm,>)]=[ansi(hm,<)][ansi(hw,Description)][ansi(hm,>)]%r%t+scene/schedule/reschedule [ansi(hm,<)][ansi(hw,Schedule ID)][ansi(hm,>)]=[ansi(hm,<)][ansi(hw,Month)][ansi(hm,>)] [ansi(hm,<)][ansi(hw,Day)][ansi(hm,>)] [ansi(hm,<)][ansi(hw,Time)][ansi(hm,>)]%r%t+scene/schedule/del [ansi(hm,<)][ansi(hw,Schedule ID)][ansi(hm,>)]%r%rWorkings:%r%rThe first command lists the schedule of scenes planned for the coming [spellnum(u(data`scheduledefault))] days. If you wish to indicate a daterange, you can do so. It accepts a 'month day year-month day year' where year is optional.%r%rThe second command allows you to view a schedule'd scene - that is to say, read the title, date and most importantly, its /description/.%r%rThe third command allows you to schedule a scene. [ansi(hr,The time is required to be in 24h format)], and presumes [ansi(u,this server's timezone)] ([timefmt($Z)]). It is [extract(elements(time(),4),1,2,:)] now.%r%rThe alternative fourth also indicates what room the scene will be in. [ansi(hur,It uses the room you are /currently/ in as the room!)], that means [name(%l)] in your case right now! %r%rThe fifth command is similar to the third one. It simply reschedules a scene you already have planned. Please try not to reschedule scenes that have already taken place - but it won't disallow it!%r%rThe last command allows you to delete a scheduled scene from the system. Just point it at the ID.%r%r[ansi(hg,Examples)]: %r[space(4)]+scene/schedule/reschedule 999=February 20 19:30%r[space(4)]+scene/schedule/add 06/20 18:32 This is a Scene=This is my description%r[space(4)]+scene/schedule/add/here 06/20 18:32 This is a Scene=This is my description
&MSG`HELP`SETUP u(scenesys)=Syntax: %r%t[v(data`gameprefix)]scene/setup %r%t[v(data`gameprefix)]scene/desetup %r%t[v(data`gameprefix)]scene/resetup%r%rWorkings:%r%rSets you up for the use of the Scene System. Desetup and resetup do the logical thing - but do not assign you a new playerid.
&MSG`HELP`STATE u(scenesys)=There are a total of three states in the system at this time. %r%r0 ([ansi(hgu,Active)]) - A scene is being RPed in currently. People can join freely. They show up in [u(FUN`display`cmdtag,+scene/mine)] and [u(FUN`display`cmdtag,+scene/list)].%r[u(FUN`display`midline)]%r1 ([ansi(hyu,Paused)]) - The same as Active in all ways but visual representation. Pose in the scene to reset it to active.%r[u(FUN`display`midline)]%r2 ([ansi(u,Unfinished)]) - New characters can no longer 'join' this scene - but a member of the scene can '+scene/activate' it. Pose in the scene to set it active again. You can find your unfinished scenes in [u(FUN`display`cmdtag,+scene/mine/unfinished)].%r[u(FUN`display`midline)]%r3 ([ansi(hwu,Finished)]) - A scene is set this way because of someone using +scene/finish or setting it in the config options. People can no longer join it, poses are no longer recorded. If you wish to amend or continue in the scene, first use: [ansi(h,+scene/config [ansi(m,<)]SceneID[ansi(m,>)]/scene_state=0)]. [u(FUN`display`cmdtag,+scene/mine/finished)] to see your finished scenes.
&MSG`HELP`SYNTAX u(scenesys)=The scene system, even though it indicates all commands in the following format: [ansi(hw,[v(data`gameprefix)]scene/[ansi(hm,<[ansi(hw,subsystem)]>)] [ansi(hm,<[ansi(hw,arguments)]>)])]... but it also accepts different manners of writing it.%r%r[ansi(hw,Prefix:)] + - @  = ! . ~ or simply no prefix are all accepted.%r[space(4)][ansi(hw,Example:)] '@scene' or '.scene' or simply 'scene'%r%r[ansi(hw,Subsystem:)] #subsystem or /subsystem%r[space(4)][ansi(hw,Example:)] 'scene/info 1' or 'scene #info 1'
&MSG`HELP`UNDO u(scenesys)=Syntax: %r%t[v(data`gameprefix)]scene/undo%r%rWhen you just posed, and made a mistake in the pose, you can use +scene/undo to toss this pose - telling the system to ignore it for display purposes. Not that you can only undo your last pose - though if it's really needed, you can use +scene/move in order to forcibly override this.
&MSG`HELP`WIZCONFIG u(scenesys)=Syntax: %r%t[v(data`gameprefix)]scene/config ([ansi(hm,<)][ansi(hw,Scene Or Setting)][ansi(hm,>)])%r%t[v(data`gameprefix)]scene/config/set ([ansi(hm,<)][ansi(hw,Scene)][ansi(hm,>)]/)[ansi(hm,<)][ansi(hw,Setting)][ansi(hm,>)]=[ansi(hm,<)][ansi(hw,Value)][ansi(hm,>)]%r%rWorkings:%r%rThe first command is for displaying purposes only. The second sets a setting in a scene. If no scene is defined - it sets the global defaults!
&MSG`HELP`WIZINSTALL u(scenesys)=TO BE REWRITTEN. %r%rSee the data`install attribute for manual install requirements and hints.
&MSG`HELP`WIZMINE u(scenesys)=Syntax: %r%t[v(data`gameprefix)]scene/mine [ansi(hm,<)][ansi(hw,Player)][ansi(hm,>)]%r%rWorkings:%r%rShows that player's 'mine' screen.
&MSG`HELP`WIZSETUP u(scenesys)=Syntax: %r%t[v(data`gameprefix)]scene/setup [ansi(hm,<)][ansi(hw,Player)][ansi(hm,>)]%r%t[v(data`gameprefix)]scene/desetup [ansi(hm,<)][ansi(hw,Player)][ansi(hm,>)]%r%t[v(data`gameprefix)]scene/resetup [ansi(hm,<)][ansi(hw,Player)][ansi(hm,>)]%r%rWorkings:%r%rSets you up for the use of the Scene System. Desetup and resetup do the logical thing - but do not assign you a new playerid.
&MSG`IGNORESET u(scenesys)=Ignore to pose %1 has been turned [if(%0,on,off)].
&MSG`INSTALL u(scenesys)=
&MSG`INSTALL`DONE u(scenesys)=Install done! We hope...
&MSG`INSTALL`NOPARENT u(scenesys)=Please give a valid room DB. Because we can't find your room parent. Another option is to set your ancestor_room in @config // mush.cnf.
&MSG`INSTALL`SQLCHECK u(scenesys)=
&MSG`INSTALL`SQLCHECK`BAD u(scenesys)=Something went wrong. There are tables we do not recognize, or there are tables missing. We cannot quite tell. The following were left over from a 'diff' between your database and the tables in DATA`SQL`TABLES: %0. If you need any assistance, please contact Mercutio. See: [ansi(hw,ex %!/credits)]
&MSG`INVALIDSCHEDULETIMELINE u(scenesys)=Sorry, [ansi(hw,%0)] is not a valid timeline.
&MSG`INVALIDSTATUS u(scenesys)=ansi(hr,%0) is an invalid scene status. Try 'paused', 'active', 'finished' or 'unfinished'.
&MSG`INVALIDTIMESTRING u(scenesys)=%0 is an invalid timestring.
&MSG`KICK u(scenesys)=
&MSG`KICK`EVENT u(scenesys)=name(%0) kicked name(%1) from scene %2.
&MSG`LOCKSET u(scenesys)=switch(u(FUN`lock`testlock,%0,%1),#-1*,Invalid lock. Scene unlocked. Set a proper lock with +scene/config/set %2/scene_lock=<value>.,0,Lock Set: %0\, but you cannot pass it yourself. Seems somewhat silly\, no?,Lock Set: %0.)
&MSG`MOVE u(scenesys)=
&MSG`MOVE`NOTSURE u(scenesys)=We are not sure what to do with this? See '+scene/help move' for help on using this command.
&MSG`NEWPOSE u(scenesys)=name(%2) just posed to your current scene.
&MSG`NOACTIVESCENE u(scenesys)=You have no scene set as 'active'.
&MSG`NOHELPFILE u(scenesys)=No such file found: %0
&MSG`NOPOSEBYPLAYER u(scenesys)=No pose made by [switch(%0,%1,you,name(%0))] yet.
&MSG`NOSCHEDULEID u(scenesys)=I could not find a scheduled scene corresponding to that schedule ID.
&MSG`NOSCHEMA u(scenesys)=We do not have SELECT rights to `information_schema`! That's not good! Fix this! Without it, SceneSys won't work properly.
&MSG`NOSUCHORDERID u(scenesys)=if(%2,Replacement is out of bounds (Position %0). Try moving the pose elsewhere.,There is no such OrderId (%0) in that scene!)
&MSG`NOSUCHPLAYER u(scenesys)=No such player found.
&MSG`NOSUCHPLAYERID u(scenesys)=No such playerid found. They may not be set up for the SceneSystem.
&MSG`NOSUCHPOSE u(scenesys)=There is no such pose.
&MSG`NOSUCHSCENE u(scenesys)=if(%0,'%0' is not a valid or existing scene ID.,You are not in a scene\, or there is no active one here. Try giving a scene ID.)
&MSG`NOTSCENEOWNER u(scenesys)=You are not the owner to this scene.
&MSG`NOTSTAFF u(scenesys)=You are not staff.
&MSG`NOUNDONE u(scenesys)=No recent undone poses found to redo.
&MSG`ORDERIDEXCHANGE u(scenesys)=The poses belonging to order_ids %1 and %2 have been exchanged within scene %0.
&MSG`PLAYERID u(scenesys)=
&MSG`PLAYERID`NOT u(scenesys)='%0' is not a valid playerid!
&MSG`SCENE u(scenesys)=
&MSG`SCENE`CREATE u(scenesys)=You successfully created a scene, it is registered under Scene #%0.
&MSG`SCENE`CREATE`TITLE u(scenesys)=Its title is now set as: "[ansi(hw,%0)]".
&MSG`SCENE`JOIN u(scenesys)=switch(%0,%1,You joined scene #%2,u(FUN`get`name,%1) added [u(FUN`get`name,%0)] to scene #%2).
&MSG`SCENE`LEAVE u(scenesys)=switch(%1:%3,%0:%0,You left scene #%2.,%0:*,u(FUN`get`name,%1) left scene #%2,*:%0,You were removed from scene #%2 by [u(FUN`get`name,%1)].,u(FUN`get`name,%0) was removed from scene #%2 by [u(FUN`get`name,%1)].
&MSG`SCHEDULE u(scenesys)=
&MSG`SCHEDULE`ALREADYHAVESCENETHATDAY u(scenesys)=You already have a scene scheduled that day.
&MSG`SCHEDULE`DEL u(scenesys)=Schedule ID %0 has been removed from the system.
&MSG`SCHEDULE`RESCHEDULE u(scenesys)=[name(%0)] rescheduled '%1' to [ansi(hw,%2)].
&MSG`SCHEDULE`SUCCESS u(scenesys)=We've successfully set your scene. You can find it on the schedule on [u(FUN`display`cmdtag,+scene/schedule [first(%2,|)],first(%2,|))] as scene [u(FUN`display`cmdtag,+scene/schedule/view %0,%0)].
&MSG`SETUNFINISHED u(scenesys)=Scene %0 has been set Unfinished[switch(%1,%2,. You can find it in [u(FUN`display`cmdtag,+scene/mine/unfinished)].,%bin a former player's scene.)] See [u(FUN`display`cmdtag,+scene/help state)] for help about unfinished scenes.
&MSG`SETUP u(scenesys)=Setup messages. Probably just the 'setup needed' one.
&MSG`SETUP`ALREADYDONE u(scenesys)=You triggered setup for '[u(FUN`get`name,%0)] (%0)' while they are already setup! Did you mean to re-setup them?
&MSG`SETUP`COMPLETE u(scenesys)=Setup of [u(FUN`get`name,%0)] ([first(%0,:)]) complete.
&MSG`SETUP`NEEDED u(scenesys)=[switch(%0,%#,You,%0)] still need[switch(%0,%#,,s)] to setup for SceneSys. Please use the following command: '[ansi(hw,+scene/setup)]'
&MSG`SETUP`REMOVED u(scenesys)=Player id '%0' has been deactivated from SceneSys.
&MSG`SETUP`RESETUP u(scenesys)=Player id '%0' has been re-setup for SceneSys.
&MSG`SOMETHINGWENTWRONG u(scenesys)=Something went wrong. Please alert your local Wizard - help them with the following message; %r%1:%r%0
&MSG`SQL u(scenesys)=
&MSG`SQL`ERROR u(scenesys)=We found an SQL error, and we don't know what to do with it. Warn your staffer: %0.
&MSG`UNDOLIMIT u(scenesys)=Your most recent pose was already an undone one. Either make a new pose, or ask your sceneowner to remove the following pose; %0
&MSG`WARN u(scenesys)=Time-warning, or spam-warning messages.
&MSG`WARN`SPAM u(scenesys)=Warning. You have been detected to be spamming in scene %1. Thusly, you have been removed from the scene - and the system is locked against you. Please contact a staffer if you believe this to be an unjust action.
&OVERRIDE u(scenesys)=SEE THE DATA`COMMAND_OVERRIDE attribute for information on this attribute tree! MAKE SURE to set it !no_command, or the hooked overrides won't work! And be sure to get yourself a function to use for FN`IS`IC - we default to ISIC()
&OVERRIDE`@EMIT u(scenesys)=$@emit*:@assert or(not(%0),regmatch(%0,(?s)^\\s(.+), s p))=@nspemit %#=Huh?  (Type "help" for help.); th [setr(r,speak(&%N,|%qp))] ; @include/nobreak me/include`lastpose`prepose=%qr,%: ; @message/spoof/remit %l=%qr,emitformat,%0,%#,%n,[accname(%#)],%qp,%qR,,u(FUN`islogged,%N,%:,%qr) ; @include me/include`lastpose`postpose=%qr,%: ; @include me/include`lastpose`catchpose=trimpenn(trimpenn(%qr,%t,r),%r),%:
&OVERRIDE`POSE u(scenesys)=$pose*:@assert or(not(%0),regmatch(%0,(?s)^\\s(.+), s p))=@nspemit %#=Huh?  (Type "help" for help.); th [setr(r,speak(&%N,:%qp))] ; @include/nobreak me/include`lastpose`prepose=%qr,%: ; @message/spoof/remit %l=%qr,poseformat,%0,%#,%n,[accname(%#)],%qp,%qr,,u(FUN`islogged,%N,%:,%qr) ; @include me/include`lastpose`postpose=%qr,%: ; @include me/include`lastpose`catchpose=trimpenn(%qr,%r),%:
&OVERRIDE`SAY u(scenesys)=$say*:@assert or(not(%0),regmatch(%0,(?s)^\\s(.+), s p))=@nspemit %#=Huh?  (Type "help" for help.); th [setr(r,speak(&%N,%qp))] ; @include/nobreak me/include`lastpose`prepose=%qr,%: ; @message/spoof/remit %l=%qr,sayformat,%0,%#,%n,[accname(%#)],%qp,%qr,[udefault(%#/saymodifier,says,%qp)],u(FUN`islogged,%N,%:,%qr) ; @include/nobreak me/include`lastpose`postpose=%qr,%: ; @include me/include`lastpose`catchpose=trimpenn(%qr,%r),%:
&OVERRIDE`SEMIPOSE u(scenesys)=$semipose*:@assert or(not(%0),regmatch(%0,(?s)^\\s(.+), s p))=@nspemit %#=Huh?  (Type "help" for help.); th [setr(r,speak(&%N,;%qp))] ; @include/nobreak me/include`lastpose`prepose=%qr,%: ; @message/spoof/remit %l=%qr,semiposeformat,%0,%#,%n,[accname(%#)],%qp,%qr,,,u(FUN`islogged,%N,%:,%qr) ; @include/nobreak me/include`lastpose`postpose=%qr,%: ; @include me/include`lastpose`catchpose=trimpenn(%qr,%r),%:
&SQL u(scenesys)=SQL queries. Using an edited version of Walker's SQL Wrapper to optimize and make more readable.
@set u(scenesys)/SQL=no_command
&SQL`CONFIG u(scenesys)=
&SQL`CONFIG`DEFAULTSET u(scenesys)=ALTER TABLE `$DATABASE$`.`$CONFIG$` ALTER t? SET DEFAULT ?
&SQL`CONFIG`SCENESET u(scenesys)=UPDATE `$DATABASE$`.`$CONFIG$` SET t?=? WHERE `scene_id`=?
&SQL`GET u(scenesys)=
&SQL`GET`ACTIVESCENE u(scenesys)=SELECT `activescene_id` FROM `$DATABASE$`.`$PLAYERS$` WHERE `player_id`=?
&SQL`GET`CONFIG u(scenesys)=
&SQL`GET`CONFIG`ALL u(scenesys)=SELECT `column_name`,`column_default`,`column_comment` FROM `information_schema`.`columns` WHERE `table_name` = 'scene_config'
&SQL`GET`CONFIG`ANYTABLE u(scenesys)=SELECT t? FROM `$DATABASE$`.`$CONFIG$` WHERE t? IN @?
&SQL`GET`CONFIG`SPECIFIC u(scenesys)=SELECT `column_name`,`column_default`,`column_comment` FROM `information_schema`.`columns` WHERE `table_name` = 'scene_config' AND `column_name` = ?
&SQL`GET`CONFIG`TABLEINSCENE u(scenesys)=SELECT t? FROM `$DATABASE$`.`$CONFIG$` WHERE `scene_id`=?
&SQL`GET`INSTALLINFOSCHEMA u(scenesys)=SELECT COUNT(*) FROM `information_schema`.`columns` WHERE `TABLE_SCHEMA`=?
&SQL`GET`INSTALLSHOW u(scenesys)=SHOW TABLES FROM `$DATABASE$`
&SQL`GET`OBJID u(scenesys)=
&SQL`GET`OBJID`FROM u(scenesys)=
&SQL`GET`OBJID`FROM`PLAYERID u(scenesys)=SELECT DISTINCT `player_objid` FROM `$DATABASE$`.`$PLAYERS$` WHERE `player_id` IN @?
&SQL`GET`PLAYER u(scenesys)=
&SQL`GET`PLAYER`INFO u(scenesys)=SELECT * FROM `$DATABASE$`.`$PLAYERS$` WHERE `player_id`=?
&SQL`GET`PLAYER`NAME u(scenesys)=SELECT `player_initname` FROM `$DATABASE$`.`$PLAYERS$` WHERE `player_id`=?
&SQL`GET`PLAYER`NAMESINSCENE u(scenesys)=SELECT DISTINCT `poser_name` FROM `$DATABASE$`.`$POSES$` WHERE `scene_id`=? AND `poser_id`=?
&SQL`GET`PLAYER`STATUS u(scenesys)=
&SQL`GET`PLAYER`WARNINGS u(scenesys)=SELECT `warnings` FROM `$DATABASE$`.`$PLAYERS$` WHERE `player_id`=?
&SQL`GET`PLAYERID u(scenesys)=
&SQL`GET`PLAYERID`ANNOUNCETO u(scenesys)=SELECT `player_id` FROM `$DATABASE$`.`$PLAYERS$` WHERE `scenecreate_announce`="1"
&SQL`GET`PLAYERID`FROM u(scenesys)=
&SQL`GET`PLAYERID`FROM`OBJID u(scenesys)=SELECT `player_id` FROM `$DATABASE$`.`$PLAYERS$` WHERE `player_objid`=?
&SQL`GET`PLAYERID`FROM`PLAYERID u(scenesys)=SELECT `player_id` FROM `$DATABASE$`.`$PLAYERS$` WHERE `player_id` = ?
&SQL`GET`PLAYERID`FROM`POSERS u(scenesys)=SELECT `poser_playerid` FROM `$DATABASE$`.`$POSER$` WHERE `scene_id` = ?
&SQL`GET`PLAYERID`FROM`SCENEPOSES u(scenesys)=SELECT DISTINCT `poser_id` FROM `$DATABASE$`.`$POSES$` WHERE `scene_id`=?
&SQL`GET`PLAYERID`HASACTIVESCENE u(scenesys)=SELECT `player_id` FROM `$DATABASE$`.`$PLAYERS$` WHERE `activescene_id` IS NOT NULL
&SQL`GET`PLAYERID`SPAMMER u(scenesys)=SELECT `spammer` FROM `$DATABASE$`.`$PLAYERS$` WHERE `player_id`=?
&SQL`GET`POSE u(scenesys)=
&SQL`GET`POSE`BODY u(scenesys)=SELECT `pose_penn` FROM `$DATABASE$`.`$POSES$` WHERE `pose_id`=? LIMIT 1
&SQL`GET`POSE`COUNT u(scenesys)=
&SQL`GET`POSE`COUNT`INSCENE u(scenesys)=SELECT COUNT(`pose_id`) FROM `$DATABASE$`.`$POSES$` WHERE `scene_id`=? AND `ignore`="0"
&SQL`GET`POSE`COUNT`INSCENE`FROMPLAYER u(scenesys)=SELECT COUNT(`pose_id`) FROM `$DATABASE$`.`$POSES$` WHERE `poser_id`=? AND `scene_id`=? AND `ignore`="0"
&SQL`GET`POSE`FROM_TILL_NOW u(scenesys)=SELECT `pose_id` FROM `$DATABASE$`.`$POSES$` WHERE ( `pose_time` BETWEEN ? and NOW() ) AND `ignore`=0 AND `scene_id` IN @?
&SQL`GET`POSE`ID u(scenesys)=
&SQL`GET`POSE`ID`LAST u(scenesys)=SELECT `pose_id` FROM `$DATABASE$`.`$POSES$` ORDER BY `pose_id` DESC LIMIT 1
&SQL`GET`POSE`ID`LAST`FROM u(scenesys)=
&SQL`GET`POSE`ID`LAST`FROM`PLAYER_ID u(scenesys)=SELECT `pose_id` FROM `$DATABASE$`.`$POSES$` WHERE `poser_id`=? ORDER BY `pose_id` DESC LIMIT 1
&SQL`GET`POSE`ID`LAST`FROM`PLAYER_ID_AND_SCENE u(scenesys)=SELECT `pose_id` FROM `$DATABASE$`.`$POSES$` WHERE `poser_id`=? AND `scene_id`=? ORDER BY `pose_id` DESC LIMIT 1
&SQL`GET`POSE`ID`POSEID u(scenesys)=SELECT `pose_id` FROM `$DATABASE$`.`$POSES$` WHERE `pose_id`=?
&SQL`GET`POSE`ID`RECALL u(scenesys)=SELECT a.`pose_id` FROM (SELECT `pose_id`,`order_id` FROM `scene`.`scene_poses` WHERE `scene_id`=? AND `order_id` BETWEEN ? AND ? AND `ignore`="0") AS a ORDER BY order_id ASC
&SQL`GET`POSE`ID`RECALLREV u(scenesys)=SELECT a.`pose_id` FROM (SELECT `pose_id`,`order_id` FROM `scene`.`scene_poses` WHERE `scene_id`=? AND `ignore`="0" ORDER BY order_id DESC LIMIT a?) AS a ORDER BY order_id ASC
&SQL`GET`POSE`ID`SCENE_AND_ORDER u(scenesys)=SELECT `pose_id` FROM `$DATABASE$`.`$POSES$` WHERE `scene_id`=? AND `order_id`=?
&SQL`GET`POSE`IGNORE u(scenesys)=SELECT `ignore` FROM `$DATABASE$`.`$POSES$` WHERE `pose_id`=? LIMIT 1
&SQL`GET`POSE`IGNORE_PLAYERSCENE u(scenesys)=SELECT `ignore` FROM `$DATABASE$`.`$POSES$` WHERE `scene_id`=? AND `poser_id`=? ORDER BY `order_id` DESC LIMIT 1
&SQL`GET`POSE`INFO u(scenesys)=SELECT t? FROM `$DATABASE$`.`$POSES$` WHERE `pose_id`=?
&SQL`GET`POSE`LATEST u(scenesys)=
&SQL`GET`POSE`LATEST`SCENEPLAYER u(scenesys)=SELECT `pose_id` FROM `$DATABASE$`.`$POSES$` WHERE `scene_id`=? AND `poser_id`=? ORDER BY `order_id` DESC LIMIT 1
&SQL`GET`POSE`ORDER u(scenesys)=
&SQL`GET`POSE`ORDER`LASTINSCENE u(scenesys)=SELECT `order_id` FROM `$DATABASE$`.`$POSES$` WHERE `scene_id`=? ORDER BY `order_id` DESC LIMIT 1
&SQL`GET`POSE`ORDER_ID u(scenesys)=
&SQL`GET`POSE`ORDER_ID`MAX u(scenesys)=SELECT MAX(`order_id`) FROM `$DATABASE$`.`$POSES$` WHERE `scene_id`=?
&SQL`GET`POSE`POSER u(scenesys)=SELECT `poser_name` FROM `$DATABASE$`.`$POSES$` WHERE `pose_id`=? LIMIT 1
&SQL`GET`POSE`TABLEINFO u(scenesys)=SELECT t? FROM `$DATABASE$`.`$POSES$` WHERE `pose_id`=? LIMIT 1
&SQL`GET`SCENE u(scenesys)=
&SQL`GET`SCENE`FORPAUSE u(scenesys)=SELECT * FROM ( SELECT poses.`scene_id`,`scene_ctime`,`pose_time` FROM `$DATABASE$`.`$POSES$` as poses INNER JOIN `$DATABASE$`.`$CONFIG$` as config ON poses.`scene_id`=config.`scene_id` AND `scene_state`='0' GROUP BY config.scene_id ORDER BY pose_time DESC ) as groupedcontent WHERE NOT (`pose_time` BETWEEN ?<0> AND ?<1> OR `scene_ctime` BETWEEN ?<0> AND ?<1>)
&SQL`GET`SCENE`FORPAUSE_AUTO u(scenesys)=SELECT scene_id FROM ( SELECT DISTINCT config.`scene_id`,`scene_ctime`,MAX(`pose_time`) as pose_time,`timeout_skip`,`timeout_pause`,`timeout_unfinished` FROM `$DATABASE$`.`$POSES$` as poses INNER JOIN `$DATABASE$`.`$CONFIG$` as config ON poses.`scene_id`=config.`scene_id` AND `scene_state`='0' GROUP BY config.scene_id ORDER BY pose_time DESC ) as groupedcontent WHERE NOT ( (`pose_time` BETWEEN (NOW()- INTERVAL `timeout_pause` SECOND) AND NOW()) OR (`scene_ctime` BETWEEN (NOW()- INTERVAL `timeout_pause` SECOND) AND NOW() ) )
&SQL`GET`SCENE`FORPAUSE_AUTO2 u(scenesys)=SELECT scene_id FROM ( SELECT DISTINCT config.`scene_id`,`scene_ctime`,MAX(`pose_time`) as pose_time,`timeout_skip`,`timeout_pause`,`timeout_unfinished` FROM `$DATABASE$`.`$POSES$` as poses INNER JOIN `$DATABASE$`.`$CONFIG$` as config ON poses.`scene_id`=config.`scene_id` AND `scene_state`='0' GROUP BY config.scene_id ORDER BY pose_time DESC ) as groupedcontent WHERE NOT ( (`pose_time` BETWEEN (NOW()- INTERVAL `timeout_pause` SECOND) AND NOW()) OR (`scene_ctime` BETWEEN (NOW()- INTERVAL `timeout_pause` SECOND) AND NOW() ) )
&SQL`GET`SCENE`FORUNFINISHED_AUTO u(scenesys)=SELECT scene_id FROM ( SELECT DISTINCT config.`scene_id`,`scene_ctime`,MAX(`pose_time`) as pose_time,`timeout_skip`,`timeout_pause`,`timeout_unfinished` FROM `$DATABASE$`.`$POSES$` as poses INNER JOIN `$DATABASE$`.`$CONFIG$` as config ON poses.`scene_id`=config.`scene_id` AND `scene_state` IN ('0','1') GROUP BY config.scene_id ORDER BY pose_time DESC ) as groupedcontent WHERE NOT ( (`pose_time` BETWEEN (NOW()- INTERVAL `timeout_unfinished` SECOND) AND NOW()) OR (`scene_ctime` BETWEEN (NOW()- INTERVAL `timeout_unfinished` SECOND) AND NOW() ) )
&SQL`GET`SCENE`INFO u(scenesys)=SELECT * FROM `$DATABASE$`.`$CONFIG$` WHERE `scene_id`=?
&SQL`GET`SCENE`INFO`SPECIFIC u(scenesys)=SELECT t? FROM `$DATABASE$`.`$CONFIG$` WHERE `scene_id`=?
&SQL`GET`SCENE`LASTVALIDACTIVE u(scenesys)=SELECT `$CONFIG$`.`scene_id` FROM `$DATABASE$`.`$POSES$` INNER JOIN `$DATABASE$`.`$CONFIG$` ON `$POSES$`.`scene_id`=`$CONFIG$`.`scene_id` WHERE `poser_id`=? AND (`scene_state`="1" OR `scene_state`="0") ORDER BY `pose_time` DESC LIMIT 1
&SQL`GET`SCENE`LATEST u(scenesys)=SELECT `scene_id` FROM `$DATABASE$`.`$CONFIG$` ORDER BY `scene_id` DESC LIMIT 1
&SQL`GET`SCENE`LISTINFO u(scenesys)=SELECT `scene_title`,`scene_owner`,`scene_ctime`,`scene_etime`,`scene_ordered`,`scene_state` FROM `$DATABASE$`.`$CONFIG$` WHERE `scene_id`=? AND `scene_private`="0"
&SQL`GET`SCENE`OWNER u(scenesys)=SELECT `scene_owner` FROM `$DATABASE$`.`$CONFIG$` WHERE `scene_id`=?
&SQL`GET`SCENE`OWNERID u(scenesys)=SELECT `scene_owner` FROM `$DATABASE$`.`$CONFIG$` WHERE `scene_id`=?
&SQL`GET`SCENE`RECENTATLOCATION u(scenesys)=SELECT `$CONFIG$`.`scene_id` FROM `$DATABASE$`.`$POSES$` INNER JOIN `$DATABASE$`.`$CONFIG$` ON `$POSES$`.`scene_id`=`$CONFIG$`.`scene_id` WHERE `pose_room`=? AND (`scene_state`="1" OR `scene_state`="0") AND (`pose_time` BETWEEN ? AND ? OR `scene_ctime` BETWEEN ?<1> AND ?<2>) ORDER BY `pose_time` DESC LIMIT 1
&SQL`GET`SCENE`RECENTATLOCATION`ALL u(scenesys)=SELECT DISTINCT `$CONFIG$`.`scene_id` FROM `$DATABASE$`.`$POSES$` INNER JOIN `$DATABASE$`.`$CONFIG$` ON `$POSES$`.`scene_id`=`$CONFIG$`.`scene_id` WHERE `pose_room`=? AND (`scene_state`="1" OR `scene_state`="0") AND `pose_time` BETWEEN ? AND ? ORDER BY `pose_time` DESC a?
&SQL`GET`SCENE`SPAMTIMER u(scenesys)=SELECT `spam_timer` FROM `$DATABASE$`.`$CONFIG$` WHERE `scene_id`=?
&SQL`GET`SCENES u(scenesys)=Gets scene IDs
&SQL`GET`SCENES`FROM u(scenesys)=
&SQL`GET`SCENES`FROM`FILTER u(scenesys)=
&SQL`GET`SCENES`FROM`FILTER`SCENE_STATE u(scenesys)=SELECT `scene_id` FROM `$DATABASE$`.`$CONFIG$` WHERE `scene_state` IN @? and `scene_id` IN @?
&SQL`GET`SCENES`FROM`PLAYER_ID u(scenesys)=SELECT `scene_id` FROM `$DATABASE$`.`$POSER$` WHERE `poser_playerid` IN @?
&SQL`GET`SCENES`FROM`SCENEID u(scenesys)=SELECT `scene_id` FROM `$DATABASE$`.`$CONFIG$` WHERE `scene_id` IN @?
&SQL`GET`SCENES`FROM`STATUS u(scenesys)=SELECT `scene_id` FROM `$DATABASE$`.`$CONFIG$` WHERE `scene_state` IN @? AND `scene_private` IN @?
&SQL`GET`SCENES`FROM`STATUS_ROOM u(scenesys)=SELECT `scene_id` FROM `$DATABASE$`.`$CONFIG$` WHERE `scene_state` LIKE ? AND `pose_room`=? AND `scene_private` IN @?
&SQL`GET`SCHEDULE u(scenesys)=
&SQL`GET`SCHEDULE`FULLBYID u(scenesys)=SELECT * FROM `$DATABASE$`.`$SCHEDULE$` WHERE `id`=?
&SQL`GET`SCHEDULE`IDS u(scenesys)=SELECT `id` FROM `$DATABASE$`.`$SCHEDULE$` WHERE `time` BETWEEN ? AND ? ORDER BY `time` ASC
&SQL`GET`SCHEDULE`IDS`BYIDS u(scenesys)=SELECT `id` FROM `$DATABASE$`.`$SCHEDULE$` WHERE `id` IN @?
&SQL`GET`SCHEDULE`IDS`ONDAYBYPLAYER u(scenesys)=SELECT `id` FROM `$DATABASE$`.`$SCHEDULE$` WHERE CAST(`time` AS DATE) = CAST(? AS DATE) AND `player_id`= ?
&SQL`GET`STATUS u(scenesys)=
&SQL`GET`STATUS`FROM u(scenesys)=
&SQL`GET`STATUS`FROM`POSERS u(scenesys)=SELECT `poser_skip` FROM `$DATABASE$`.`$POSER$` WHERE `scene_id`=? AND `poser_playerid`=?
&SQL`GET`TABLE u(scenesys)=SELECT `column_name` FROM `information_schema`.`columns` WHERE `table_name` = ? AND `column_name` LIKE ?
&SQL`GET`TABLECOMMENT u(scenesys)=SELECT `column_comment` FROM `information_schema`.`columns` WHERE `table_name` = ? AND `column_name` LIKE ?
&SQL`GET`TIME u(scenesys)=
&SQL`GET`TIME`BETWEEN u(scenesys)=SELECT COUNT(*) FROM d? WHERE t?=? AND t?=? AND (t? BETWEEN ? AND ?)
&SQL`GET`TIME`DIFF u(scenesys)=SELECT IFNULL(ABS(DATEDIFF(?,?)),0)
&SQL`PLAYER u(scenesys)=
&SQL`PLAYER`DESETUP u(scenesys)=UPDATE `$DATABASE$`.`$PLAYERS$` SET `setup`="0" WHERE `player_id`=?
&SQL`PLAYER`RESETUP u(scenesys)=UPDATE `$DATABASE$`.`$PLAYERS$` SET `setup`="1" WHERE `player_id`=?
&SQL`PLAYER`SETUP u(scenesys)=INSERT INTO `$DATABASE$`.`$PLAYERS$` (player_objid,player_initname,bitlevel) VALUES (?,?,?)
&SQL`POSE u(scenesys)=
&SQL`POSE`ADD u(scenesys)=INSERT INTO `$DATABASE$`.`$POSES$` (order_id,scene_id,owner_id,poser_id,poser_name,pose_time,pose_room,pose_room_name) VALUES ( IFNULL( (SELECT `order_id` FROM `$DATABASE$`.`$POSES$` as x WHERE x.`scene_id`=?<0> ORDER BY x.`order_id` DESC LIMIT 1) ,0)+1 , ?<0> , (SELECT `scene_owner` FROM `$DATABASE$`.`$CONFIG$` WHERE `scene_id`=?<0>) , (SELECT `player_id` FROM `$DATABASE$`.`$PLAYERS$` WHERE `player_objid`=?<1>) ,?<2>,?<3>,?<4>,?<5> )
&SQL`POSE`CHANGEORDERID u(scenesys)=UPDATE `$DATABASE$`.`$POSES$` SET `order_id`=a? WHERE `pose_id`=?
&SQL`POSE`MOVEORDERID u(scenesys)=
&SQL`POSE`MOVEORDERID`0 u(scenesys)=START TRANSACTION
&SQL`POSE`MOVEORDERID`1 u(scenesys)=UPDATE `$DATABASE$`.`$POSES$` SET `order_id`=`order_id`+?<2> WHERE `order_id`>=LEAST(CONVERT(?<0>,SIGNED),CONVERT(?<1>,SIGNED)) AND `scene_id`=?<3>
&SQL`POSE`MOVEORDERID`2 u(scenesys)=UPDATE `$DATABASE$`.`$POSES$` SET `order_id`=?<1> WHERE `order_id`=?<0>+?<2> AND `scene_id`=?<3>
&SQL`POSE`MOVEORDERID`3 u(scenesys)=UPDATE `$DATABASE$`.`$POSES$` SET `order_id`=`order_id`-?<2>+SIGN(?<0>-?<1>) WHERE `scene_id`=?<3> AND `order_id`!=?<1> AND `order_id` BETWEEN ?<1> AND GREATEST(CONVERT(?<0>,SIGNED),CONVERT(?<1>,SIGNED))+?<2>
&SQL`POSE`MOVEORDERID`4 u(scenesys)=UPDATE `$DATABASE$`.`$POSES$` SET `order_id`=`order_id`-?<2> WHERE `scene_id`=?<3> AND `order_id`>GREATEST(CONVERT(?<0>,SIGNED),CONVERT(?<1>,SIGNED))+?<2>
&SQL`POSE`MOVEORDERID`5 u(scenesys)=COMMIT
&SQL`POSE`UPDATEPLAIN u(scenesys)=UPDATE `$DATABASE$`.`$POSES$` SET `pose_penn`=? WHERE `pose_id`=?
&SQL`POSE`UPDATEPLAINADD u(scenesys)=UPDATE `$DATABASE$`.`$POSES$` SET `pose_penn`=CONCAT( (SELECT `pose_penn` FROM (SELECT `pose_id`,`pose_penn` FROM `$DATABASE$`.`$POSES$`) AS x WHERE x.pose_id=?<1>) ,?<0>) WHERE pose_id=?<1>
&SQL`POSER u(scenesys)=
&SQL`POSER`ADD u(scenesys)=INSERT INTO `$DATABASE$`.`$POSER$` (`scene_id`,`poser_playerid`) VALUES (?,?)
&SQL`POSER`REM u(scenesys)=DELETE FROM `$DATABASE$`.`$POSER$` WHERE `scene_id`=? AND `poser_playerid`=?
&SQL`SET u(scenesys)=
&SQL`SET`ACTIVESCENE u(scenesys)=UPDATE `$DATABASE$`.`$PLAYERS$` SET `activescene_id`=a? WHERE `player_id`=?
&SQL`SET`BASICSCENE u(scenesys)=INSERT INTO `$DATABASE$`.`$CONFIG$` (`scene_players`,`scene_owner`,`scene_ctime`,`scene_state`) VALUES (?,?,?,"0")
&SQL`SET`POSE u(scenesys)=
&SQL`SET`POSE`IGNORE u(scenesys)=UPDATE `$DATABASE$`.`$POSES$` SET `ignore`=? WHERE `pose_id`=?
&SQL`SET`SCHEDULE u(scenesys)=INSERT INTO `$DATABASE$`.`$SCHEDULE$` (time,title,player_id,name,description,room) VALUES (?,?,?,?,?,?)
&SQL`SET`SCHEDULE`DELETE u(scenesys)=DELETE FROM `$DATABASE$`.`$SCHEDULE$` WHERE `id`=?
&SQL`SET`SCHEDULE`UPDATE u(scenesys)=UPDATE `$DATABASE$`.`$SCHEDULE$` SET `time`=? WHERE `id`=?
&STARTUP u(scenesys)=@@ This will initialize the main trigger loop - that does most of the 'smart' work of this system. Make sure this object is set NO_PAY - see the TRIG`LOOP attribute comment. And while we are at it, may as well make sure we have the minimum required @config values.                                                                                                    ; @config/set player_queue_limit=[inc(u(data`maxbuffer))]                    ; @include/nobreak me/include`loop ;  @assert u(data`command_override); @include me/include`override
@set u(scenesys)/STARTUP=no_command prefixmatch
&W u(scenesys)=Contains Walker's SQL Wrapper, slightly editted. Quoting walker; "Yes, it's ugly code, but it's ugly so yours can be clean!"
@set u(scenesys)/W=no_debug
&W`ARGUMENTS u(scenesys)=Contains the w`arguments used in front of the '?' sign. Example: t? will assume a 'table', d? will automatically insert the 'database', and add on your 'table' argument. Stuff like that. To add new ones, simply add a 'system', which will get '%0' as the text as the incoming argument, and 'sign' underneath that to indicate what 'symbol' before the ? to associate with. Example: &w`arguments`capitalized_a wrapper="[sqlescape(edit(%0,a,A))]" (( and then )) &w`arguments`captalized_a`sign wrapper=&   (( Mind you not to use '=' as a 'sign'! ))
@set u(scenesys)/W`ARGUMENTS=no_debug
&W`ARGUMENTS`ARRAY u(scenesys)=([map(#lambda/"\[sqlescape(\%0)\]",strfirstof(%0,lit(>CYx95\%7D#\(oY\%f\{dloJ)),%b,\,)])
@set u(scenesys)/W`ARGUMENTS`ARRAY=no_debug
&W`ARGUMENTS`ARRAY`SIGN u(scenesys)=@
@set u(scenesys)/W`ARGUMENTS`ARRAY`SIGN=no_debug
&W`ARGUMENTS`DATATABLE u(scenesys)=`[v(data`sql`database)]`.`$[capstr(%0)]$`
@set u(scenesys)/W`ARGUMENTS`DATATABLE=no_debug
&W`ARGUMENTS`DATATABLE`SIGN u(scenesys)=d
@set u(scenesys)/W`ARGUMENTS`DATATABLE`SIGN=no_debug
&W`ARGUMENTS`DIRECT u(scenesys)=%0
@set u(scenesys)/W`ARGUMENTS`DIRECT=no_debug
&W`ARGUMENTS`DIRECT`SIGN u(scenesys)=a
@set u(scenesys)/W`ARGUMENTS`DIRECT`SIGN=no_debug
&W`ARGUMENTS`GLOB2LIKE u(scenesys)="[regeditall(sqlescape(%0),\[_\%\],\\$0,((?:\[^\\\\\]|^)(?:\\\\\\\\\\\\\\\\)*)(\[?\\*\]),$1[switch($2,\\?,_,\\*,\%)])]"
@set u(scenesys)/W`ARGUMENTS`GLOB2LIKE=no_debug
&W`ARGUMENTS`GLOB2LIKE`SIGN u(scenesys)=_
@set u(scenesys)/W`ARGUMENTS`GLOB2LIKE`SIGN=no_debug
&W`ARGUMENTS`STANDARD u(scenesys)=%b"[sqlescape(%0)]"
@set u(scenesys)/W`ARGUMENTS`STANDARD=no_debug
&W`ARGUMENTS`STANDARD`SIGN u(scenesys)=%b
@set u(scenesys)/W`ARGUMENTS`STANDARD`SIGN=no_debug
&W`ARGUMENTS`TABLE u(scenesys)=`[edit(%0,.,`.`)]`
@set u(scenesys)/W`ARGUMENTS`TABLE=no_debug
&W`ARGUMENTS`TABLE`SIGN u(scenesys)=t
@set u(scenesys)/W`ARGUMENTS`TABLE`SIGN=no_debug
&W`ARGUMENTS`TRUEESCAPE u(scenesys)='[sqlescape(%0)]'
@set u(scenesys)/W`ARGUMENTS`TRUEESCAPE=no_debug
&W`ARGUMENTS`TRUEESCAPE`SIGN u(scenesys)=!
@set u(scenesys)/W`ARGUMENTS`TRUEESCAPE`SIGN=no_debug
&W`CREDITS u(scenesys)=Original SQL wrapper created by Walker. Other credit goes to Mercutio for slight edits; inclusion of w`datatokens and expanded w`arguments.
@set u(scenesys)/W`CREDITS=no_debug
&W`DATATOKENS u(scenesys)=regeditalli(%0,`\\$([edit(u(w`fn`get`tablelist),%b,|)]|database)\\$`,`[switch($1,database,v(data`sql`database),u(w`fn`get`tablename,#$))]`)
@set u(scenesys)/W`DATATOKENS=no_debug
&W`FN u(scenesys)=General Functions
@set u(scenesys)/W`FN=no_debug
&W`FN`GET u(scenesys)=Gets information.
@set u(scenesys)/W`FN`GET=no_debug
&W`FN`GET`ARGUMENTATTR u(scenesys)=firstof(first(revwords(rest(revwords(grep(me,w`arguments`*`sign,decompose(%0)),`),`),`)),W`ARGUMENTS`STANDARD)
@set u(scenesys)/W`FN`GET`ARGUMENTATTR=no_debug
&W`FN`GET`ARGUMENTLIST u(scenesys)=iter(lattr(me/w`arguments`*`sign),u(%i0),,)
@set u(scenesys)/W`FN`GET`ARGUMENTLIST=no_debug
&W`FN`GET`TABLELIST u(scenesys)=iter(lattr(me/data`sql`table`),last(%i0,`))
@set u(scenesys)/W`FN`GET`TABLELIST=no_debug
&W`FN`GET`TABLENAME u(scenesys)=v(data`sql`table`%0)
@set u(scenesys)/W`FN`GET`TABLENAME=no_debug
&W`FN`TRANSFORM u(scenesys)=Transforms information. Like the w`datatokens, or the general 'prepare'.
@set u(scenesys)/W`FN`TRANSFORM=no_debug
&W`FN`TRANSFORM`DATATOKENS u(scenesys)=regeditalli(%0,`\\$([edit(u(w`fn`get`tablelist),%b,|)]|database)\\$`,`[switch($1,database,v(data`sql`database),u(w`fn`get`tablename,$1))]`)
@set u(scenesys)/W`FN`TRANSFORM`DATATOKENS=no_debug
&W`FN`TRANSFORM`PREPARE u(scenesys)=u(w`datatokens, regeditall(firstof(v(sql`[before(%0,:)]`[config(sql_platform)]),v(sql`[before(%0,:)])),(\[[u(w`fn`get`argumentlist)]\]?)\\?(?:<(\\d+)>)?,u(u(w`fn`get`argumentattr,$1),v(if(strlen($2),add($2,1),setr(i,inc(%qi)))))) )
@set u(scenesys)/W`FN`TRANSFORM`PREPARE=no_debug
&W`MAPQUERY u(scenesys)=localize(setq(i,1)[mapsql(%0,u(w`fn`transform`prepare,%1,%2,%3,%4,%5,%6,%7,%8,%9),firstof(elements(%1,2,:),%r),elements(%1,3,:))])
@set u(scenesys)/W`MAPQUERY=no_debug
&W`PREPARE u(scenesys)=localize(setq(i,0)[eval(me,w`fn`transform`prepare)])
@set u(scenesys)/W`PREPARE=no_debug
&W`QUERY u(scenesys)=setq(i,0)[sql(eval(me,w`fn`transform`prepare),firstof(elements(%0,2,:),%b),firstof(elements(%0,3,:),%b),s)]
@set u(scenesys)/W`QUERY=no_debug
&W`UPDATE u(scenesys)=localize(if(strlen(setr(0,eval(me,w`query))),%q0,firstof(sql(select last_insert_id(),,,s),%qs)))
@set u(scenesys)/W`UPDATE=no_debug
&W`WRAPPER u(scenesys)=SQL Wrapper. Detailed in the following CPO post: http://community.pennmush.org/story/sql-prepared-statements-mushcode. Editted by Mercutio to allow for expanded arguments (see 'arguments' argument) and the datatokens: `$DATABASE$` or `$TABLENAMEGOESHERE$`, as defined in data`sql`database and data`sql`table`tablenamegoeshere. It can handle a series of arguments that were not previously supported - and it is easy to add new ones. See the ARGUMENTS attribute tree. Sign-leafs for the marks, normal for the actualy replacement code.
@set u(scenesys)/W`WRAPPER=no_debug